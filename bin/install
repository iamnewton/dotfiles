#!/usr/bin/env bash
set -euo pipefail

# Set default permissions for new files and directories to 755/644
# Ensures created files are owner-writable, but not group/world-writable (e.g., ~/.ssh, ~/.config)
# Helps avoid accidentally creating insecure or overly permissive files
umask 022

# Constants
readonly USERNAME="iamnewton"
readonly REPO="dotfiles"
readonly INSTALL_DIR="$HOME/.local/lib/$REPO"

readonly GITHUB_URL="github.com"
readonly GIT_AUTHOR_NAME="Newton"
readonly GIT_AUTHOR_EMAIL="5769156+iamnewton@users.noreply.github.com"
readonly GIT_CONFIG_FILE="$HOME/.config/git/local"

# ANSI color codes
PURPLE="\033[1;35m"
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
RESET="\033[0m"
LOG_PREFIX="[${PURPLE}${REPO}${RESET}]"

# Logging functions
error() {
	echo -e "${LOG_PREFIX}: ❌ ${RED}$1${RESET}" >&2
}

log() {
	echo -e "${LOG_PREFIX}: ${BLUE}$1${RESET}"
}

success() {
	echo -e "${LOG_PREFIX}: ✅ ${GREEN}$1${RESET}"
}

warn() {
	echo -e "${LOG_PREFIX}: ⚠️  ${YELLOW}$1${RESET}"
}

install_homebrew() {
	log "🔧 Installing Homebrew and packages..."
	local brew_paths
	brew_paths=(
		"/opt/homebrew/bin/brew"
		"/usr/local/bin/brew"
		"/home/linuxbrew/.linuxbrew/bin/brew"
	)

	if ! command -v brew &>/dev/null; then
		log "🔧 Homebrew not found — attempting installation"

		if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
			error "Homebrew installation failed"
			return 1
		fi

		# Try to locate brew and source its shellenv
		for path in "${brew_paths[@]}"; do
			if [[ -x "$path" ]]; then
				log "🔗 Sourcing Homebrew environment from: $path"
				eval "$("$path" shellenv)"
				break
			fi
		done

		# Re-check if brew is available after install
		if ! command -v brew &>/dev/null; then
			error "Homebrew installed, but binary not found in expected paths"
			return 1
		fi
	else
		log "Homebrew already installed"
		eval "$(brew shellenv)"
	fi

	# Defensive check again before installing
	if ! command -v brew &>/dev/null; then
		error "brew command not available — aborting package install"
		return 1
	fi

	log "📦 Installing Homebrew packages"
	brew install \
		bash bash-completion@2 bat coreutils ctags fzf gcc gh git git-delta \
		gnupg gron jq lazygit less mosh n nvim rsync ripgrep spaceman-diff \
		ssh-copy-id tig tmux tree wget whalebrew z
	success "Homebrew packages installed"
}

clone_repo() {
	log "📥 Cloning and setting up dotfiles repository..."
	local tmp_tar
	tmp_tar="$(mktemp "/tmp/$REPO.XXXXXX.tar.gz")"
	local repo_url="https://$GITHUB_URL/$USERNAME/$REPO"

	if [[ ! -d "$INSTALL_DIR" ]]; then
		log "📥 Cloning ${REPO} repository from $repo_url"
		mkdir -p "$INSTALL_DIR" || {
			error "Failed to create directory: $INSTALL_DIR"
			return 1
		}

		if ! curl -#fLo "$tmp_tar" "$repo_url/tarball/main"; then
			error "Failed to download tarball from $repo_url"
			return 1
		fi

		if ! tar -zxf "$tmp_tar" --strip-components 1 -C "$INSTALL_DIR"; then
			error "Failed to extract ${REPO} tarball to $INSTALL_DIR"
			return 1
		fi

		rm -f "$tmp_tar"
		success "${REPO} extracted to $INSTALL_DIR"
	else
		log "📁 ${REPO} directory already exists: $INSTALL_DIR"
	fi

	if command -v git &>/dev/null && [[ ! -d "$INSTALL_DIR/.git" ]]; then
		log "🔧 Initializing Git repository in $INSTALL_DIR"
		pushd "$INSTALL_DIR" >/dev/null || {
			error "Could not enter directory: $INSTALL_DIR"
			return 1
		}

		git init
		git branch -m main
		git remote add origin "$repo_url.git"

		if ! git fetch origin main; then
			error "Git fetch failed from $repo_url"
			return 1
		fi

		if ! git reset --hard FETCH_HEAD; then
			error "Git reset failed"
			return 1
		fi

		git clean -fd || warn "Git clean produced warnings"
		git pull --rebase origin main || {
			error "Git pull --rebase failed"
			return 1
		}

		popd >/dev/null
		success "Git repo setup complete"
	else
		log "Git already initialized or unavailable — skipping Git setup"
	fi
}

symlink_binary() {
	log "🔗 Setting up binary symlink..."
	local filepath="$INSTALL_DIR/bin/${REPO}"
	local target="$HOME/.local/bin/$REPO"

	if [[ ! -x "$filepath" ]]; then
		warn "Binary not found or not executable: $filepath"
		return 1
	fi

	mkdir -p "$(dirname "$target")" || {
		error "Failed to create directory: $target"
		return 1
	}

	log "🔗 Linking $filepath → $target"
	if ln -sfn "$filepath" "$target"; then
		success "Linked $filepath → $target"
	else
		error "Failed to link from $filepath to $target"
		return 1
	fi
}

# Symlink everything in the conf directory as a dotfile
# All of these files are meant to be at the room/HOME directory
# so when naming them, name appropriately
symlink_dotconfigs() {
	log "🔗 Symlinking dotconfig files to home directory..."
	local source_dir="${INSTALL_DIR}/conf"

	if [[ ! -d "$source_dir" ]]; then
		error "Directory not found: $source_dir"
		return 1
	fi

	for filepath in "$source_dir"/*; do
		[[ -f "$filepath" ]] || continue # Skip non-files (like subdirs)

		local filename
		filename="$(basename "$filepath")"
		local target="$HOME/.$filename"

		log "🔗 Linking $filepath → $target"
		if ln -sfn "$filepath" "$target"; then
			success "Linked $filepath → $target"
		else
			error "Failed to link from $filepath to $target"
			return 1
		fi
	done
}

# Symlink all OS specific files.
# Anything in these directories should be named darwin or linux,
# based on the output of the `uname` command
symlink_os_files() {
	log "🔗 Linking OS-specific configuration files..."
	local base_dir="${INSTALL_DIR}/lib"
	local os
	os="$(uname | tr '[:upper:]' '[:lower:]')" # 'darwin' or 'linux'

	if [[ ! -d "$base_dir" ]]; then
		error "Directory does not exist: $base_dir"
		return 1
	fi

	log "🔍 Linking OS-specific configs for: $os"

	# Find matching OS-specific config files (e.g., lib/tmux/darwin)
	find "$base_dir" -type f -name "$os" | while read -r filepath; do
		local relative_dir target_filename target

		relative_dir="${filepath#$base_dir/}"                      # e.g., ssh/darwin
		target_filename="$(basename "$(dirname "$relative_dir")")" # e.g., ssh
		case "$target_filename" in
		ssh)
			target="$HOME/.ssh/config"
			log "🔗 Copying $filepath → $target"
			mkdir -p "$(dirname "$target")" || {
				error "Failed to create directory: $target"
			}
			if cp "$filepath" "$target"; then
				success "Copied $filepath → $target"
			else
				error "Failed to copy from $filepath to $target"
				return 1
			fi
			;;
		tmux)
			target="$HOME/.tmux.conf"
			log "🔗 Linking $filepath → $target"
			if ln -sfn "$filepath" "$target"; then
				success "Linked $filepath → $target"
			else
				error "Failed to link from $filepath to $target"
				return 1
			fi
			;;
		git)
			target_path="$HOME/.gitconfig"
			log "🔗 Linking $filepath → $target_path"
			if ln -sfn "$filepath" "$target"; then
				success "Linked $filepath → $target"
			else
				error "Failed to link from $filepath to $target"
				return 1
			fi
			;;
		*)
			warn "Skipping unknown config type: $target_filename"
			continue
			;;
		esac
	done
}

setup_ls_colors() {
	log "🔗 Linking OS-specific configuration files..."
	if [[ ! -f "$HOME/.config/dircolors" ]]; then
		if ! command -v dircolors &>/dev/null; then
			error "'dircolors' not found. Install coreutils via Homebrew."
			return 1
		fi

		readonly LS_REPO="LS_COLORS"
		local TMP_DIR
		TMP_DIR="$(mktemp -d "/tmp/${LS_REPO}.XXXXXX")"
		local tmp_tar
		tmp_tar="$(mktemp "/tmp/${LS_REPO}.XXXXXX.tar.gz")"
		local repo_url="https://github.com/trapd00r/$LS_REPO"

		log "Installing dircolors from $LS_REPO"

		if ! curl -#fLo "$tmp_tar" "$repo_url/tarball/master"; then
			error "Failed to download tarball from $repo_url"
			return 1
		fi

		if ! tar -zxf "$tmp_tar" --strip-components 1 -C "$TMP_DIR"; then
			error "Failed to extract ${LS_REPO} tarball to $TMP_DIR"
			return 1
		fi

		if [[ -f "$TMP_DIR/LS_COLORS" ]]; then
			dircolors -b "$TMP_DIR/${LS_REPO}" >"$HOME/.config/dircolors"
			success "Installed ${LS_REPO} to $HOME/.config/dircolors"
		else
			error "${LS_REPO} file not found in extracted tarball."
			return 1
		fi

		rm -rf "$TMP_DIR" "$tmp_tar"
	else
		log "${LS_REPO} already installed."
	fi
}

setup_bash_profile_local() {
	log "🛠️ Setting up .bash_profile.local..."
	[[ -f "$HOME/.bash_profile.local" ]] || echo '#!/usr/bin/env bash' >"$HOME/.bash_profile.local"
	grep -qF ".bash_profile.local" "$HOME/.bash_profile" 2>/dev/null ||
		echo '[[ -f ~/.bash_profile.local ]] && source ~/.bash_profile.local' >>"$HOME/.bash_profile"
	success "Setup .bash_profile.local and sourced from .bash_profile"

	# Add DOTFILES_DIR if not present
	if ! grep -q "DOTFILES_DIR=" "$HOME/.bash_profile.local"; then
		echo "export DOTFILES_DIR=\"$INSTALL_DIR\"" >>"$HOME/.bash_profile.local"
		success "DOTFILES_DIR added to .bash_profile.local"
	else
		log "DOTFILES_DIR already defined in .bash_profile.local"
	fi
}

setup_github_token() {
	log "🔐 Configuring GitHub token..."
	if command -v curl &>/dev/null; then
		read -rp "What's your GitHub personal token? " GITHUB_TOKEN
		if [[ -n "$GITHUB_TOKEN" ]]; then
			grep -q "machine github.com" "$HOME/.netrc" 2>/dev/null || {
				cat <<EOF >>"$HOME/.netrc"
machine github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine api.github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine raw.githubusercontent.com
  login $GITHUB_TOKEN
  password x-oauth-basic
EOF
			}
			echo "export GITHUB_TOKEN=$GITHUB_TOKEN" >>"$HOME/.bash_profile.local"
			success "Configured GitHub token in .netrc and .bash_profile.local"
		fi
	fi
}

setup_git_author() {
	log "👤 Setting up Git author name and email..."
	if command -v git &>/dev/null; then
		local current_name current_email
		current_name=$(git config --file "$GIT_CONFIG_FILE" user.name 2>/dev/null || echo "")
		current_email=$(git config --file "$GIT_CONFIG_FILE" user.email 2>/dev/null || echo "")

		if [[ -z "$current_name" ]]; then
			read -rp "Enter Git name [default: $GIT_AUTHOR_NAME]: " input_name
			git config --file "$GIT_CONFIG_FILE" user.name "${input_name:-$GIT_AUTHOR_NAME}"
			success "Git name set to: ${input_name:-$GIT_AUTHOR_NAME}"
		else
			log "Git name already set to: $current_name"
		fi

		if [[ -z "$current_email" ]]; then
			read -rp "Enter Git email [default: $GIT_AUTHOR_EMAIL]: " input_email
			git config --file "$GIT_CONFIG_FILE" user.email "${input_email:-$GIT_AUTHOR_EMAIL}"
			success "Git email set to: ${input_email:-$GIT_AUTHOR_EMAIL}"
		else
			log "Git email already set to: $current_email"
		fi
	fi
}

setup_gpg_key() {
	log "🔑 Generating and configuring GPG key..."
	if command -v gpg &>/dev/null; then
		# Ensure GNUPGHOME is set, fallback to ~/.config/gnupg if not
		export GNUPGHOME="${GNUPGHOME:-$HOME/.config/gnupg}"

		mkdir -p "$GNUPGHOME" || {
			error "Failed to create directory: $GNUPGHOME"
			return 1
		}

		log "Generating GPG key (this may open interactive prompts)"
		gpg --gen-key
		gpg --list-secret-keys --keyid-format LONG

		read -rp "Enter GPG key ID: " GIT_GPG_KEY
		if [[ -z "$GIT_GPG_KEY" ]]; then
			error "No GPG key ID provided. Aborting."
			return 1
		fi

		git config --file "$GIT_CONFIG_FILE" user.signingkey "$GIT_GPG_KEY"
		log "Configured Git to sign with: $GIT_GPG_KEY"
		gpg --armor --export "$GIT_GPG_KEY"
		success "GPG key exported. Add to GitHub → https://github.com/settings/keys"

		# Secure permissions
		chmod 700 "$GNUPGHOME"
		find "$GNUPGHOME" -type f -exec chmod 600 {} \;
		success "GPG directory permissions secured."
	fi
}

change_login_shell() {
	log "🐚 Changing login shell to Homebrew Bash..."
	local os new_shell
	os="$(uname | tr '[:upper:]' '[:lower:]')"
	new_shell="$(brew --prefix)/bin/bash"

	if [[ "$SHELL" == "$new_shell" ]]; then
		log "Login shell already set to: $new_shell"
		return 0
	fi

	if [[ "$os" == "darwin" ]]; then
		if ! command -v sudo >/dev/null; then
			error "'sudo' is required but not installed"
			warn "Manually add $new_shell to /etc/shells and set it with 'chsh -s $new_shell'"
			return 1
		fi

		echo "$new_shell" | pbcopy
		if ! sudo vim + -c 'startinsert' -c ':r !pbpaste' -c ':xa' /etc/shells; then
			error "Failed to add $new_shell to /etc/shells"
			warn "Manually add $new_shell to /etc/shells and set it with 'chsh -s $new_shell'"
			return 1
		fi
	elif [[ "$os" == "linux" ]]; then
		if ! sudo chsh -s "$new_shell" "$USER"; then
			error "Failed to change login shell to $new_shell"
			warn "Run 'chsh -s $new_shell' manually to change your login shell"
			return 1
		fi
	fi

	success "Login shell changed to Homebrew Bash"
}

symlink_configs() {
	log "🔗 Symlinking app config directories to ~/.config..."
	local source_dir="$INSTALL_DIR/share/config"
	local target_dir="$HOME/.config"

	if [[ ! -d "$source_dir" ]]; then
		error "Source config directory does not exist: $source_dir"
		return 1
	fi

	mkdir -p "$target_dir" || {
		error "Failed to create directory: $target_dir"
		return 1
	}

	# Iterate only over first-level items (files and directories)
	for item in "$source_dir"/*; do
		local name
		name="$(basename "$item")"
		local target="$target_dir/$name"

		log "🔗 Linking $name → $HOME/.config/$name"
		if ln -sfn "$item" "$target"; then
			success "Linked $name → $HOME/.config/$name"
		else
			error "Failed to link from $name to $target"
			return 1
		fi
	done
}

main() {
	local start_time end_time
	start_time=$(date +%s)
	trap 'end_time=$(date +%s); log "⏱️ Setup completed in $((end_time - start_time)) seconds"' EXIT

	install_homebrew
	clone_repo
	symlink_binary
	symlink_dotconfigs
	symlink_os_files
	setup_ls_colors
	setup_bash_profile_local
	setup_github_token
	setup_git_author
	setup_gpg_key
	change_login_shell
	symlink_configs

	success "${REPO} installed. Open a new terminal session"
}

main

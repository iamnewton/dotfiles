#!/usr/bin/env bash
set -euo pipefail

# Set default permissions for new files and directories to 755/644
# Ensures created files are owner-writable, but not group/world-writable (e.g., ~/.ssh, ~/.config)
# Helps avoid accidentally creating insecure or overly permissive files
umask 022

# Constants
readonly OS="$(uname | tr '[:upper:]' '[:lower:]')"

# User variables
readonly USERNAME="iamnewton"
readonly REPO="dotfiles"
readonly INSTALL_DIR="$HOME/.local/lib/$REPO"

readonly GIT_AUTHOR_NAME="${GIT_AUTHOR_NAME:-Newton}"
readonly GIT_AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-5769156+iamnewton@users.noreply.github.com}"
readonly GIT_CONFIG_FILE="$HOME/.gitconfig.local"
readonly BASH_PROFILE_LOCAL_FILE="$HOME/.bash_profile.local"

# ANSI color codes
readonly CYAN="\033[36m"
readonly PURPLE="\033[1;35m"
readonly RED="\033[1;31m"
readonly GREEN="\033[1;32m"
readonly YELLOW="\033[1;33m"
readonly BLUE="\033[1;34m"
readonly DIM_WHITE="\033[2;37m"
readonly BOLD_WHITE="\033[1;97m"
readonly BRIGHT_WHITE="\033[97m"
readonly UNDERLINE="\033[4m"
readonly RESET="\033[0m"
readonly LOG_PREFIX="${PURPLE}[${REPO}]${RESET}"

# Logging destinations
readonly LOG_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/$REPO/install.log"
readonly BREWFILE_LOG_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/$REPO/brewfile_installation.$(date +%Y-%m-%d_%H-%M-%S).log"
readonly LOG_TO_FILE="${DOTFILES_LOG_TO_FILE:-true}"
readonly LOG_TO_SYSLOG="${DOTFILES_LOG_TO_SYSLOG:-true}"

# print out some fun header
# @url: https://patorjk.com/software/taag/#p=testall&h=1&v=1&f=Doh&t=dotfiles
print_banner() {
	cat <<'EOF'


            dddddddd
            d::::::d                          tttt             ffffffffffffffff    iiii  lllllll
            d::::::d                       ttt:::t            f::::::::::::::::f  i::::i l:::::l
            d::::::d                       t:::::t           f::::::::::::::::::f  iiii  l:::::l
            d:::::d                        t:::::t           f::::::fffffff:::::f        l:::::l
    ddddddddd:::::d    ooooooooooo   ttttttt:::::ttttttt     f:::::f       ffffffiiiiiii  l::::l     eeeeeeeeeeee        ssssssssss
  dd::::::::::::::d  oo:::::::::::oo t:::::::::::::::::t     f:::::f             i:::::i  l::::l   ee::::::::::::ee    ss::::::::::s
 d::::::::::::::::d o:::::::::::::::ot:::::::::::::::::t    f:::::::ffffff        i::::i  l::::l  e::::::eeeee:::::eess:::::::::::::s
d:::::::ddddd:::::d o:::::ooooo:::::otttttt:::::::tttttt    f::::::::::::f        i::::i  l::::l e::::::e     e:::::es::::::ssss:::::s
d::::::d    d:::::d o::::o     o::::o      t:::::t          f::::::::::::f        i::::i  l::::l e:::::::eeeee::::::e s:::::s  ssssss
d:::::d     d:::::d o::::o     o::::o      t:::::t          f:::::::ffffff        i::::i  l::::l e:::::::::::::::::e    s::::::s
d:::::d     d:::::d o::::o     o::::o      t:::::t           f:::::f              i::::i  l::::l e::::::eeeeeeeeeee        s::::::s
d:::::d     d:::::d o::::o     o::::o      t:::::t    tttttt f:::::f              i::::i  l::::l e:::::::e           ssssss   s:::::s
d::::::ddddd::::::ddo:::::ooooo:::::o      t::::::tttt:::::tf:::::::f            i::::::il::::::le::::::::e          s:::::ssss::::::s
 d:::::::::::::::::do:::::::::::::::o      tt::::::::::::::tf:::::::f            i::::::il::::::l e::::::::eeeeeeee  s::::::::::::::s
  d:::::::::ddd::::d oo:::::::::::oo         tt:::::::::::ttf:::::::f            i::::::il::::::l  ee:::::::::::::e   s:::::::::::ss
   ddddddddd   ddddd   ooooooooooo             ttttttttttt  fffffffff            iiiiiiiillllllll    eeeeeeeeeeeeee    sssssssssss


EOF
}

# print out some stats about the machine/installer
print_stats() {
	echo "üñ•Ô∏è Host:"
	echo "    Hostname:    $(hostname)"
	if command -v sw_vers &>/dev/null; then
		echo "    OS Version:  $(sw_vers -productName) $(sw_vers -productVersion)"
	else
		echo "    OS Release:  $(lsb_release -d 2>/dev/null | cut -f2-)$(grep PRETTY_NAME /etc/os-release | cut -d= -f2-)"
	fi
	echo "    Kernel:      $(uname -sr)"
	echo

	echo "üêö Shell & User:"
	echo "    User:        $(whoami)"
	echo "    Shell:       $(ps -p $$ -o comm=) ($(basename $SHELL))"
	echo

	echo "üíæ Disk Usage:"
	echo "    Root:        $(df -h / | awk 'NR==2 { printf "%s used, %s free\n", $3, $4 }')"
	echo "    Home:        $(df -h "$HOME" | awk 'NR==2 { printf "%s used, %s free\n", $3, $4 }')"
	echo

	echo "üåê Network:"
	echo "    Local IP:    $(hostname -I 2>/dev/null || ipconfig getifaddr en0 2>/dev/null || echo unknown)"
	echo "    Public IP:   $(curl -s ifconfig.me || echo unknown)"
	echo
}

# Internal helper: log to file if enabled
_log_to_file() {
	local level="$1"
	local msg="$2"
	echo "[$(date '+%Y-%m-%d %H:%M:%S')][$level] $msg" >>"$LOG_FILE"
}

# Internal helper: send to macOS Console.app if enabled
_log_to_syslog() {
	[[ "$OS" != "darwin" ]] && return 0
	command -v logger >/dev/null || return 0
	local msg="$1"
	logger -t $REPO "$msg"
}

# Suppress command output to stdout but log elsewhere
run_quietly() {
	local output cmd="$*"
	output="$("$@" 2>&1)" || {
		_log_to_file "ERROR" "$cmd"
		_log_to_syslog "[ERROR] $cmd"
		[[ "${DEBUG:-false}" == "true" ]] && echo "$output"
		return 1
	}

	_log_to_file "INFO" "$cmd"
	_log_to_syslog "[INFO] $cmd"
	[[ "${DEBUG:-false}" == "true" ]] && echo "$output"
	return 0
}

# Logging functions
log() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t${DIM_WHITE}${msg}${RESET}"
	_log_to_file "LOG" "$msg"
	_log_to_syslog "$msg"
}
header() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: ${BRIGHT_WHITE}${msg}${RESET}"
}
section() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}:"
	echo -e "${LOG_PREFIX}: ${BOLD_WHITE}${msg}${RESET}"
}
info() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t‚ÑπÔ∏è  ${BLUE}${msg}${RESET}"
	_log_to_file "INFO" "$msg"
	_log_to_syslog "[INFO] $msg"
}
warn() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t‚ö†Ô∏è  ${YELLOW}${msg}${RESET}"
	_log_to_file "WARN" "$msg"
	_log_to_syslog "[WARN] $msg"
}
error() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t‚ùå ${RED}${msg}${RESET}" >&2
	_log_to_file "ERROR" "$msg"
	_log_to_syslog "[ERROR] $msg"
}
success() {
	local msg="${1:-}"
	local is_final="${2:-false}"

	local prefix="${LOG_PREFIX}:\t"
	if [[ "$is_final" == "true" ]]; then
		prefix="${LOG_PREFIX}: "
	fi

	echo -e "${prefix}${GREEN}‚úÖ ${msg}${RESET}"
	_log_to_file "SUCCESS" "$msg"
	_log_to_syslog "[SUCCESS] $msg"
}

# ‚îÄ‚îÄ‚îÄ prompt_for Function ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# prompt_for <VAR_NAME> <PROMPT_MESSAGE>
#  ‚Ä¢ If $VAR_NAME is already non-empty, skips prompt.
#  ‚Ä¢ If running under CI (CI or GITHUB_ACTIONS env), skips prompt.
#  ‚Ä¢ Otherwise, does a colored interactive read into $VAR_NAME.
prompt_for() {
	local varname="$1"
	local message="$2"

	local cyan=$'\033[36m'
	local reset=$'\033[0m'
	local tab=$'\t'
	local log_prefix=$'\033[1;35m[dotfiles]\033[0m'

	# safe indirect expansion: defaults to empty if unset
	local current="${!varname:-}"

	if [[ -n "$current" ]]; then
		info "${message} (already set)"
		return 0
	fi

	if [[ -n "${CI-}" || -n "${GITHUB_ACTIONS-}" ]]; then
		info "${message} (skipping prompt in CI)"
		return
	fi

	read -rp "${log_prefix}:${tab}${cyan}${message}:${reset} " "$varname"
}

is_interactive() {
	if [[ -n "${CI-}" || -n "${GITHUB_ACTIONS-}" ]]; then
		return 1
	fi

	[[ -t 1 && -n "$TERM" && "$TERM" != "dumb" ]]
}

# loading graphic for long running processes
loading() {
	local print_output=false
	local delay=0.1
	local spinstr='|/-\'
	local pid
	local i=0

	# Check for --print-output flag
	if [[ "$1" == "--print-output" ]]; then
		print_output=true
		shift
	fi

	if [ "$#" -lt 3 ]; then
		error "Usage: loading [--print-output] <command...> <success_msg> <failure_msg>"
		return 1
	fi

	# The last two arguments are success and failure messages
	local success_msg="${@: -2:1}"
	local failure_msg="${@: -1}"

	# All the rest are command and args
	local cmd_args=("${@:1:$(($# - 2))}")

	# Run command redirecting output to temp file
	"${cmd_args[@]}" >"$BREWFILE_LOG_FILE" 2>&1 &
	pid=$!

	if is_interactive; then
		tput civis # hide cursor
	fi
	printf "%b:\t " "${LOG_PREFIX}"

	while kill -0 "$pid" 2>/dev/null; do
		printf "\b%c" "${spinstr:i++%${#spinstr}:1}"
		sleep $delay
	done

	wait $pid
	local exit_code=$?

	# Clear spinner char
	# printf "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
	# Clean spinner
	if is_interactive; then
		tput cnorm # show cursor again
	fi
	printf "\r%*s\r" "$(tput cols)" "" # full clear

	# Optionally print output
	if [ "$print_output" = true ]; then
		cat "$BREWFILE_LOG_FILE"
	fi

	if [ $exit_code -eq 0 ]; then
		success "$success_msg"
	else
		error "$failure_msg"
	fi

	return $exit_code
}

# Ensure log dir exists
init_log_file() {
	mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || {
		warn "Failed to create log directory: $(dirname "$LOG_FILE")"
		return 1
	}

	touch "$LOG_FILE" 2>/dev/null || {
		warn "Failed to create log file: $LOG_FILE"
		return 1
	}
}

# Install Homebrew if missing and activate its shell environment
install_homebrew() {
	log "üîé Checking for Homebrew..."

	if ! command -v brew >/dev/null 2>&1; then
		log "üç∫ Installing Homebrew"

		if [[ -n "${CI:-}" || -n "${DOTFILES_NONINTERACTIVE:-}" || ! -t 1 ]]; then
			if ! NONINTERACTIVE=1 run_quietly /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
				error "Homebrew installation failed (non-interactive)"
				return 74
			fi
		else
			if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
				error "Homebrew installation failed"
				return 74
			fi
		fi

		# Find the installed brew binary
		local brew_bin
		for path in /opt/homebrew/bin/brew /usr/local/bin/brew /home/linuxbrew/.linuxbrew/bin/brew; do
			if [[ -x "$path" ]]; then
				brew_bin="$path"
				break
			fi
		done

		if [[ -z "${brew_bin:-}" ]]; then
			error "Failed to find installed brew binary"
			return 70 # EX_SOFTWARE
		fi

		# Shellenv activation
		log "üîß Configuring Homebrew environment: $brew_bin"
		eval "$("$brew_bin" shellenv)" || {
			error "Failed to configure Homebrew environment"
			return 70
		}

		success "Homebrew setup"
		return 0
	fi

	log "üîß Configuring Homebrew environment"
	if ! eval "$(brew shellenv)"; then
		error "Failed to configure Homebrew environment"
		return 70 # Internal shell eval/config error (EX_SOFTWARE)
	fi

	info "Homebrew is already setup"

	return 0
}

# Download dotfiles repo and extract it to the install directory
extract_repo() {
	log "üîé Checking for $INSTALL_DIR..."

	if [[ -d "$INSTALL_DIR" && -n "$(ls -A "$INSTALL_DIR")" ]]; then
		info "$INSTALL_DIR exists and is not empty. Skipping extraction"
		success "Using previously extracted dotfiles"
		return 0
	fi

	mkdir -p "$INSTALL_DIR" || {
		error "Failed to create directory: $INSTALL_DIR"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "üì• Downloading $REPO"
	if ! curl -fsSL "https://github.com/$USERNAME/$REPO/tarball/main" | tar -xz --strip-components=1 -C "$INSTALL_DIR"; then
		error "Failed to extract $REPO to $INSTALL_DIR"
		return 74 # I/O error from curl or tar (EX_IOERR)
	fi

	success "Downloaded & extracted $REPO to $INSTALL_DIR"
	return 0
}

# Clone or reinitialize the dotfiles repository in the install directory
clone_repo() {
	log "üîé Checking if $INSTALL_DIR is already initialized and up-to-date..."

	if [[ ! -d "$INSTALL_DIR" ]]; then
		mkdir -p "$INSTALL_DIR" || {
			error "Failed to create directory: $INSTALL_DIR"
			return 73 # Can't create directory (EX_CANTCREAT)
		}
	fi

	if ! pushd "$INSTALL_DIR" >/dev/null; then
		error "Failed to enter directory: $INSTALL_DIR"
		return 73 # Can't create directory (EX_CANTCREAT)
	fi

	# If repo already initialized, check if it's clean and up-to-date
	local repo_url fetch_branch
	repo_url="https://github.com/${USERNAME}/${REPO}.git"
	fetch_branch=${DOTFILES_BRANCH:-main}
	if [[ -d .git ]]; then
		local remote_url current_branch
		remote_url="$(git remote get-url origin 2>/dev/null || true)"
		current_branch="$(git symbolic-ref --short HEAD 2>/dev/null || echo '')"

		if git diff --quiet && git diff --cached --quiet && [[ "$remote_url" == "$repo_url" ]] && [[ "$current_branch" == "$fetch_branch" ]]; then
			info "Dotfiles repo already cloned, clean, and on $current_branch"
			popd >/dev/null
			return 0
		fi

		if [[ -n "$(git status --porcelain)" ]]; then
			warn "‚ö†Ô∏è Uncommitted changes detected: stashing them before reset"
			git stash push -u -m "dotfiles-auto-stash-before-reset" || warn "Stash failed"
			info "Your previous changes were stashed. Use \`git stash list\` to review or \`git stash pop\` to restore."
		fi
	else
		log "üÜï Initializing new Git repository"
		run_quietly git init --initial-branch=main || {
			error "Failed to initialize git repository"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}

		log "üîß Configuring default branch: main"
		git branch -m main || {
			error "Failed to rename default branch to main"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}
	fi

	log "üîß Configuring remote origin: $repo_url"
	if ! git remote | grep -q "^origin$"; then
		git remote add origin "$repo_url" || {
			error "Failed to add remote origin"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}
	else
		info "Remote origin already exists"
	fi

	log "üì• Fetching origin/$fetch_branch"
	if ! run_quietly git fetch origin $fetch_branch; then
		error "Failed to fetch from origin"
		popd >/dev/null
		return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
	fi

	log "üßπ Resetting index and working tree to origin/$fetch_branch"
	local head
	if ! head=$(git reset --hard FETCH_HEAD 2>&1); then
		error "Failed to reset to FETCH_HEAD"
		popd >/dev/null
		return 70 # Software error
	fi
	info "$head"

	log "üßΩ Cleaning untracked files"
	git clean -fd || warn "Git clean produced warnings"

	success "Repository has been initialized and reset to origin/$fetch_branch"

	log "üì§ Pulling latest changes (rebase)"
	if ! run_quietly git pull --rebase origin $fetch_branch; then
		error "Failed to pull latest changes"
		popd >/dev/null
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	log "üîÑ Updating submodules"
	if ! git submodule update --recursive --init --quiet; then
		error "Failed to update submodules"
		popd >/dev/null
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	popd >/dev/null
	success "Repository is up to date"
	return 0
}

# Symlink the main repo binary
symlink_binary() {
	local filepath target
	filepath="$INSTALL_DIR/bin/${REPO}"
	target="$HOME/.local/bin/$REPO"
	log "üîé Checking for binary at $HOME/.local/bin/$REPO..."

	if [[ "$(readlink "$target")" == "$filepath" ]]; then
		info "Binary already exists: $target ‚Üí $filepath"
		success "Using existing binary"
		return 0
	fi

	if [[ ! -x "$filepath" ]]; then
		error "Binary not found or not executable: $filepath"
		return 66 # Input file missing or not executable (EX_NOINPUT)
	fi

	mkdir -p "$(dirname "$target")" || {
		error "Failed to create directory: $(dirname "$target")"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "üîó Symlinking binary"
	if ln -sfn "$filepath" "$target"; then
		success "Symlinked binary $filepath ‚Üí $target"
	else
		error "Failed to symlink binary from $filepath to $target"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	return 0
}

# Symlink files from conf/ into dot-prefixed files in $HOME
symlink_dotconfigs() {
	log "üîé Checking for dotconfig symlinks..."

	local source_dir
	source_dir="${INSTALL_DIR}/conf"
	if [[ ! -d "$source_dir" ]]; then
		error "Directory not found: $source_dir"
		return 66 # Source directory not found (EX_NOINPUT)
	fi

	log "üîó Symlinking dotconfig files to HOME directory"
	local count total
	count=0
	total=$(($(ls -1 "$source_dir"/* 2>/dev/null | wc -l)))
	for filepath in "$source_dir"/*; do
		[[ -f "$filepath" ]] || continue

		local filename target
		filename="$(basename "$filepath")"
		target="$HOME/.$filename"

		# Remove existing file or broken symlink if it's not a symlink
		if [[ -e "$target" && ! -L "$target" ]]; then
			log "üìÅ Removing existing file: $target"
			rm -f "$target" || {
				error "Failed to remove existing file: $target"
				continue
			}
		fi

		log "üîó Symlinking $filename"
		if ln -sfn "$filepath" "$target"; then
			success "Symlinked $filepath ‚Üí $target"
			((count++))
		else
			error "Failed to symlink from $filepath to $target"
			return 70 # Symlink failed (EX_SOFTWARE)
		fi
	done

	if [[ "$count" -eq 0 ]]; then
		warn "No dotfiles were symlinked from $source_dir"
	else
		info "Symlinked $count of $total dotfile(s) from $source_dir"
	fi

	return 0
}

# Symlink OS-specific config files based on `uname`
symlink_os_files() {
	log "üîé Checking for OS-specific configuration symlinks..."

	local base_dir
	base_dir="${INSTALL_DIR}/lib"
	if [[ ! -d "$base_dir" ]]; then
		error "Directory does not exist: $base_dir"
		return 66 # Directory not found (EX_NOINPUT)
	fi

	log "üîó Symlinking OS-specific configs: $OS"
	local -a targets=("ssh" "tmux")
	local processed=0

	for sub in "${targets[@]}"; do
		local os_file="$base_dir/$sub/$OS"

		if [[ ! -f "$os_file" ]]; then
			info "No $OS config found in $sub/"
			continue
		fi

		case "$sub" in
		ssh)
			local target="$HOME/.ssh/config"
			log "üîó Copying $os_file"
			mkdir -p "$(dirname "$target")" || {
				error "Failed to create directory: $(dirname "$target")"
				continue
			}
			if cp "$os_file" "$target"; then
				success "Copied $os_file ‚Üí $target"
				((processed++))
			else
				error "Failed to copy from $os_file to $target"
			fi
			;;
		tmux)
			local target="$HOME/.tmux.conf"
			log "üîó Symlinking $os_file"
			if ln -sfn "$os_file" "$target"; then
				success "Symlinked $os_file ‚Üí $target"
				((processed++))
			else
				error "Failed to symlink from $os_file to $target"
			fi
			;;
		*)
			warn "Skipping unsupported config type: $sub"
			continue
			;;
		esac
	done

	if [[ "$processed" -gt 0 ]]; then
		info "Processed $processed of ${#targets[@]} OS-specific config(s)"
	else
		info "No OS-specific configs were symlinked"
	fi

	success "Symlinked OS-specific configs: $OS"
	return 0
}

# Symlink app configs from share/config into ~/.config/
symlink_configs() {
	log "üîé Checking app config symlinks to $HOME/.config..."

	local source_dir target_dir
	source_dir="$INSTALL_DIR/share/config"
	if [[ ! -d "$source_dir" ]]; then
		error "Source config directory does not exist: $source_dir"
		return 66 # Directory not found (EX_NOINPUT)
	fi

	target_dir="$HOME/.config"
	mkdir -p "$target_dir" || {
		error "Failed to create directory: $target_dir"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	local count=0
	for item in "$source_dir"/*; do
		[[ -e "$item" ]] || continue
		local name target
		name="$(basename "$item")"
		target="$target_dir/$name"

		# Remove existing non-symlink to avoid failure
		if [[ -e "$target" && ! -L "$target" ]]; then
			warn "Removing existing non-symlink: $target"
			rm -rf "$target"
		fi

		log "üîó Symlinking $name"
		if ln -sfn "$item" "$target"; then
			success "Symlinked $name ‚Üí $target"
			((count++))
		else
			error "Failed to symlink from $item to $target"
		fi
	done

	if [[ "$count" -eq 0 ]]; then
		warn "No configs were symlinked from $source_dir"
	else
		total=$(($(find "$source_dir" -mindepth 1 -maxdepth 1 ! -name '.*' | wc -l)))
		info "Symlinked $count of $total config(s) into $HOME/.config/"
	fi

	return 0
}

# Create a local bash profile file and set DOTFILES_DIR if not present
create_bash_profile_local() {
	log "üîé Checking if $BASH_PROFILE_LOCAL_FILE exists..."

	local profile_file="$HOME/.bash_profile"
	local export_line="export DOTFILES_DIR=\"$INSTALL_DIR\""

	# Ensure the .bash_profile.local file exists
	if [[ ! -f "$BASH_PROFILE_LOCAL_FILE" ]]; then
		log "üÜï Creating .bash_profile.local"
		echo '#!/usr/bin/env bash' >"$BASH_PROFILE_LOCAL_FILE"
		success "Created $BASH_PROFILE_LOCAL_FILE"
	else
		info "$BASH_PROFILE_LOCAL_FILE already exists"
	fi

	# Ensure it's sourced in .bash_profile
	log "üìù Writing source line to $profile_file"
	if [[ -f "$BASH_PROFILE_LOCAL_FILE" ]]; then
		if ! grep -qF "$BASH_PROFILE_LOCAL_FILE" "$profile_file"; then
			echo "[[ -f $BASH_PROFILE_LOCAL_FILE ]] && source $BASH_PROFILE_LOCAL_FILE" >>"$profile_file"
			success "Added source line to $profile_file"
		else
			info "$profile_file already sources $BASH_PROFILE_LOCAL_FILE"
		fi
	else
		warn "$profile_file not found ‚Äî skipping source line injection"
	fi

	log "üìù Writing DOTFILES_DIR to $BASH_PROFILE_LOCAL_FILE"
	# Add DOTFILES_DIR if not already present
	if ! grep -E "^export DOTFILES_DIR=" "$BASH_PROFILE_LOCAL_FILE" >/dev/null 2>&1; then
		echo "$export_line" >>"$BASH_PROFILE_LOCAL_FILE"
		success "Added DOTFILES_DIR to $BASH_PROFILE_LOCAL_FILE"
	else
		info "DOTFILES_DIR already defined in $BASH_PROFILE_LOCAL_FILE"
	fi

	return 0
}

# Install packages via Brewfile
install_homebrew_packages() {
	log "üîé Checking for Homebrew..."

	if ! command -v brew >/dev/null 2>&1; then
		warn "Homebrew not found. Attempting to reinstall Homebrew"

		if ! install_homebrew; then
			error "Failed to install Homebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		success "Installed Homebrew"
	fi

	local brewfile_path
	brewfile_path="$INSTALL_DIR/lib/homebrew/Brewfile"
	if [[ ! -f "$brewfile_path" ]]; then
		error "No Brewfile found in repo: $brewfile_path"
		return 66 # Input file not found (EX_NOINPUT)
	fi

	log "üç∫ Installing Homebrew packages from Brewfile"
	local bundle_log
	bundle_log="$(mktemp)"
	loading brew bundle --file="$brewfile_path" \
		"Installed all Homebrew packages" \
		"Failed to install packages via Brewfile. Check $BREWFILE_LOG_FILE"

	# Parse and list failed packages
	local failed=()
	while IFS= read -r line; do
		if [[ "$line" =~ ^Error:\ (.*)\!$ ]]; then
			local message="${BASH_REMATCH[1]}"
			# Try to extract the package name
			if [[ "$message" =~ install\ ([a-z0-9@._+-]+) ]]; then
				failed+=("${BASH_REMATCH[1]}")
			fi
		fi
	done <"$bundle_log"

	if ((${#failed[@]})); then
		warn "The following packages failed to install and may need to be installed manually:"
		for pkg in "${failed[@]}"; do
			echo "  - $pkg"
		done
	fi

	rm -f "$bundle_log"

	return 0
}

# Install or update Whalebrew Docker-based CLIs
install_whalebrew_packages() {
	log "üîé Checking if Whalebrew is supported..."

	if [[ -n "${CI:-}" ]]; then
		info "Running in CI environment. Skipping Whalebrew install"
		return 0
	fi

	if ! command -v docker >/dev/null && ! command -v podman >/dev/null; then
		warn "Neither Docker nor Podman is available. Skipping Whalebrew install"
		return 0
	fi

	if [[ "$OS" != "darwin" ]]; then
		warn "Whalebrew is only supported on macOS. Skipping installation on: $OS"
		return 0
	fi

	if ! command -v whalebrew >/dev/null 2>&1; then
		warn "whalebrew not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! brew install whalebrew; then
			error "Failed to install whalebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		success "Installed whalebrew"
	fi

	log "üê≥ Installing/updating Whalebrew packages"
	local images
	images=(whalebrew/ffmpeg whalebrew/httpie whalebrew/speedtest whalebrew/youtube-dl)
	for image in "${images[@]}"; do
		local name
		name=$(basename "$image")

		if whalebrew list | grep -q "^$name$"; then
			info "üîÑ Reinstalling $name..."
			whalebrew uninstall "$name"
		fi

		if whalebrew install "$image"; then
			success "Installed $name"
		else
			warn "Failed to install $name"
		fi
	done

	success "Whalebrew packages installed or updated"
	return 0
}

# Install or update global npm packages
install_npm_packages() {
	log "üîé Checking for Node.js (npm)..."

	if ! command -v npm >/dev/null 2>&1 || ! command -v node >/dev/null 2>&1; then
		warn "npm not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! brew install node; then
			warn "Failed to install Node.js (npm)"
			return 74
		fi

		success "Installed Node.js (npm)"
	fi

	log "üì¶ Installing global npm packages"
	local packages
	packages=(
		"fkill-cli:fkill"
		"fx-completion:fx"
		"is-up-cli:is-up"
		"tldr:tldr"
		"trash-cli:trash"
		"vtop:vtop"
	)
	for pair in "${packages[@]}"; do
		IFS=":" read -r pkg cmd <<<"$pair"
		if npm list -g --depth=0 "$pkg" >/dev/null 2>&1; then
			info "üîÑ Updating $cmd"
			run_quietly npm update --global --quiet "$pkg" || warn "Failed to update $pkg"
		else
			log "üì¶ Installing $cmd"
			run_quietly npm install --global --quiet "$pkg" || warn "Failed to install $pkg"
		fi

		if command -v "$cmd" >/dev/null 2>&1; then
			success "'$cmd' installed and available"
		else
			warn "'$cmd' not found in PATH after installing $pkg"
		fi
	done

	success "All npm packages installed or updated"
	return 0
}

# Prompt to install macOS App Store apps via mas and Brewfile.macos
install_macos_apps() {
	log "üîé Checking if on MacOS for app installation..."

	if [[ -n "${CI:-}" ]]; then
		info "Running in CI environment. Skipping macOS app install"
		return 0
	fi

	if [[ "$OS" != "darwin" ]]; then
		warn "Not on macOS. Skipping macOS app install"
		return 0
	fi

	local install_macos_apps_reply=""
	prompt_for install_macos_apps_reply "üñ• Install macOS apps too? (y/n)"
	# Use the env var value if already set
	install_macos_apps_reply="${install_macos_apps_reply:-${DOTFILES_MACOS_APPS:-n}}"

	if [[ ! "$install_macos_apps_reply" =~ ^[Yy]$ ]]; then
		info "You answered no. Skipping macOS app installation"
		return 0
	fi

	if ! command -v brew >/dev/null 2>&1; then
		warn "Homebrew not found. Installing"
		if ! install_homebrew || ! brew install mas; then
			warn "Failed to install macOS App Store CLI. Skipping app installations"
			return 74
		fi
	fi

	local brewfile_macos_path
	brewfile_macos_path="$INSTALL_DIR/lib/homebrew/Brewfile.macos"
	if [[ ! -f "$brewfile_macos_path" ]]; then
		error "Brewfile.macos not found at: $brewfile_macos_path"
		return 66 # Input file not found (EX_NOINPUT)
	fi

	log "üçè Installing macOS apps from Brewfile.macos..."
	if brew bundle --file="$brewfile_macos_path"; then
		success "Installed macOS apps from Brewfile.macos"
	else
		error "Failed to install apps from Brewfile.macos"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	return 0
}

# Install warp themes
install_warp_themes() {
	log "üîé Checking for Warp app..."
	
	local install_dir repo_url
	install_dir="$HOME/.warp"
	repo_url="https://github.com/warpdotdev/themes.git"

	if [[ -f "${install_dir}/themes" ]]; then
		info "Warp themes are already installed."
		return 0
	fi

	mkdir -p "$install_dir" || {
		error "Failed to create font directory: $install_dir"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	run_quietly git clone "$repo_url" "${install_dir}/themes" || {
		error "Failed to clone $repo_url"
		return 74 # I/O error from curl or tar (EX_IOERR)
	}
	success "Downloaded Warp themes into ${install_dir}/themese"
}

# Install custom TTF font included in the repo
install_fonts() {
	log "üîé Checking for font files..."

	local font_dir font_name target
	font_dir="$INSTALL_DIR/lib/fonts"
	font_name="InputMonoCondensed Nerd Font.ttf"

	if [[ ! -f "$font_dir/$font_name" ]]; then
		error "Font file not found: $font_dir/$font_name"
		return 66 # Input file missing (EX_NOINPUT)
	fi

	if [[ "$OS" == "darwin" ]]; then
		target="$HOME/Library/Fonts"
	elif [[ "$OS" == "linux" ]]; then
		target="$HOME/.local/share/fonts"
	else
		warn "Unsupported OS for font installation"
		return 0
	fi

	log "üñã  Installing font to $target..."
	mkdir -p "$target" || {
		error "Failed to create font directory: $target"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	cp "$font_dir/$font_name" "$target" || {
		error "Failed to copy font to $target"
		return 74 # I/O error downloading or extracting (EX_IOERR)
	}

	if [[ "$OS" == "linux" ]]; then
		fc-cache -f "$target"
	fi

	success "'$font_name' installed"
	return 0
}

# Set up dircolors config (LS_COLORS)
install_ls_colors() {
	log "üîé Checking if dircolors is setup..."

	if [[ -f "$HOME/.config/dircolors" ]]; then
		info "üìÅ LS_COLORS already installed."
		return 0
	fi

	if ! command -v dircolors &>/dev/null; then
		warn "dircolors not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! run_quietly brew install coreutils; then
			error "Failed to install Homebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		# Try to add the coreutils gnubin path
		local coreutils_path="$(brew --prefix)/opt/coreutils/libexec/gnubin"
		if [[ -x "$coreutils_path/dircolors" ]]; then
			export PATH="$coreutils_path:$PATH"
			info "Added $coreutils_path to PATH"
		fi

		success "Installed dircolors via coreutils via Homebrew"
	fi

	local tmp_dir repo_url
	tmp_dir="$(mktemp -d "/tmp/LS_COLORS.XXXXXX")"
	repo_url="https://github.com/trapd00r/LS_COLORS"

	log "üì• Downloading dircolors"
	if ! curl -fsSL --netrc-optional "$repo_url/tarball/master" | tar -xz --strip-components=1 -C "$tmp_dir"; then
		error "Failed to download or extract tarball from $repo_url"
		rm -rf "$tmp_dir"
		return 74 # I/O error downloading or extracting (EX_IOERR)
	fi

	log "üåà Installing dircolors from LS_COLORS"
	if [[ -f "$tmp_dir/LS_COLORS" ]]; then
		dircolors -b "$tmp_dir/LS_COLORS" >"$HOME/.config/dircolors"
		success "Installed LS_COLORS to $HOME/.config/dircolors"
	else
		error "LS_COLORS file not found in extracted tarball."
		rm -rf "$tmp_dir"
		return 66 # Input file missing (EX_NOINPUT)
	fi

	rm -rf "$tmp_dir"
	return 0
}

# Install Genmoji (https://github.com/segersniels/genmoji)
install_genmoji() {
	log "üîé Checking if Genmoji is installed..."

	if [[ "$(uname -m)" != "x86_64" ]]; then
		warn "Genmoji only supports x86_64 architectures; current architecture: "$(uname -m)". Skipping Genmoji install"
		return 0
	fi

	local install_url install_target install_repo
	install_repo="genmoji"
	install_url="https://raw.githubusercontent.com/segersniels/${install_repo}/master/scripts/install.sh"
	install_dir="$HOME/.local/lib/$install_repo"
	install_target="$HOME/.local/bin"

	# Check if already installed
	if command -v genmoji >/dev/null 2>&1; then
		info "Genmoji is already installed at: $(command -v genmoji)"
		return 0
	else
		mkdir -p "$install_dir" || {
			error "Failed to create target directory: $install_dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}

		log "üì• Downloading Genmoji"
		if run_quietly curl -fsSL --netrc-optional "$install_url" | bash -s "$install_dir"; then
			success "Genmoji downloaded to $install_dir"
		else
			error "Failed to install Genmoji"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi

		log "üé≠ Installing Genmoji to: $install_dir"
		log "üîó Symlinking $install_dir ‚Üí $install_target/$install_repo"
		if ln -sfn "$install_dir" "$install_target/$install_repo"; then
			success "Symlinked $install_dir ‚Üí $install_target/$install_repo"
		else
			error "Failed to symlink $install_dir to $install_target/$install_repo"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi
	fi

	# Prompt for OpenAI API key
	local openai_api_key_input
	if [[ -n "${OPENAI_API_KEY:-}" ]]; then
		info "Using OPENAI_API_KEY from environment"
		openai_api_key_input="$OPENAI_API_KEY"
	else
		prompt_for openai_api_key_input "üîë Enter your OpenAI API key (check Passwords app)"
	fi

	# Only export if a value was entered
	if [[ -n "$openai_api_key_input" ]]; then
		export OPENAI_API_KEY="$openai_api_key_input"

		# Add to bash_profile.local if not already present
		if grep -q "OPENAI_API_KEY=" "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null; then
			warn "OPENAI_API_KEY already set in $BASH_PROFILE_LOCAL_FILE"
		else
			echo "export OPENAI_API_KEY=\"$OPENAI_API_KEY\"" >>"$BASH_PROFILE_LOCAL_FILE"
			success "Added OPENAI_API_KEY to $BASH_PROFILE_LOCAL_FILE"
		fi
	else
		warn "No API key entered; skipping environment variable setup"
	fi

	# Confirm install
	if command -v genmoji >/dev/null 2>&1; then
		success "Genmoji is now available as: $(command -v genmoji)"
	else
		warn "Genmoji script installed, but not found in \$PATH"
		info "You may need to add '$install_dir' to your PATH manually."
	fi

	return 0
}

# Install Gitmoji Fuzzy Git commit hook
install_gitmoji_fuzzy_hook() {
	log "üîé Checking if gitmoji-fuzzy-hook is installed..."

	local filepath hooks_dir hook_path install_repo install_dir repo_url target templates_dir
	install_repo="gitmoji-fuzzy-hook"
	install_dir="$HOME/.local/lib/$install_repo"
	repo_url="https://gitlab.com/raabf/$install_repo.git"

	# Clone or update the repo
	log "üì• Downloading $install_repo"
	if [[ ! -d "$install_dir/.git" ]]; then
		mkdir -p "$install_dir" || {
			error "Failed to create directory: $install_dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}

		run_quietly git clone "$repo_url" "$install_dir" || {
			error "Failed to clone $repo_url"
			return 74 # I/O error from curl or tar (EX_IOERR)
		}
		success "Downloaded $install_repo into $install_dir"
	else
		info "Updating existing $install_repo repo"
		git -C "$install_dir" pull --quiet || warn "Could not update $install_repo"
	fi

	log "üéâ Installing gitmoji-fuzzy-hook"
	target="$HOME/.local/bin/${install_repo}-init"

	log "üîó Symlinking $install_dir/bin/${install_repo}-init.sh ‚Üí $target"
	if ln -sfn "$install_dir/bin/${install_repo}-init.sh" "$target"; then
		success "Symlinked $install_dir/bin/${install_repo}-init.sh ‚Üí $target"
	else
		error "Failed to symlink from $install_dir/bin/${install_repo}-init.sh to $target"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	# Install hook to both locations
	hooks_dir="$HOME/.config/git/hooks"
	templates_dir="$HOME/.config/git/templates/hooks"
	for dir in "$templates_dir" "$hooks_dir"; do
		mkdir -p "$dir" || {
			error "Failed to create hook directory: $dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}
		hook_path="$dir/prepare-commit-msg"
		log "üîó Installing $install_repo to $hook_path"
		if "$target" >>"$hook_path" 2>/dev/null; then
			chmod +x "$hook_path"
			success "Installed $install_repo to $hook_path"
		else
			error "Failed to generate prepare-commit-msg in $dir"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi
	done

	success "$install_repo installed and configured for Git hooks and templates"
	return 0
}

# Install FZF keybindings and shell completion
setup_fzf_keybindings() {
	log "üîé Checking for FZF keybindings and fuzzy completion..."

	# Ensure fzf is available
	if ! command -v fzf >/dev/null 2>&1; then
		warn "fzf not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! run_quietly brew install fzf; then
			error "Failed to install fzf"
			return 74 # EX_UNAVAILABLE
		fi

		success "Installed fzf"
	fi

	log "üõ† Setting up FZF keybindings and fuzzy completion"
	local install_script
	install_script="$(brew --prefix)/opt/fzf/install"

	if [[ ! -x "$install_script" ]]; then
		error "FZF install script not found at $install_script"
		return 66 # EX_NOINPUT
	fi

	log "üîß Running fzf install script (no rc updates)"
	if run_quietly "$install_script" --key-bindings --completion --no-update-rc; then
		success "FZF keybindings and completion installed"
	else
		error "FZF install script failed to run successfully"
		return 70
	fi

	return 0
}

# Prompt user for GitHub token and write to .netrc and local bash profile
setup_github_token() {
	log "üîé Checking for GitHub token..."

	local token_input=""
	if [[ -n "${GITHUB_TOKEN:-}" ]]; then
		token_input="$GITHUB_TOKEN"
		info "GITHUB_TOKEN is already set in environment"
	else
		log "üîß Configuring GitHub token: (https://github.com/settings/tokens)"
		prompt_for token_input "üîë Enter your GitHub personal access token"
	fi

	if [[ -z "$token_input" ]]; then
		warn "No token entered, skipping GitHub token setup"
		return 0
	fi

	export GITHUB_TOKEN="$token_input"
	local netrc_path
	netrc_path="$HOME/.netrc"

	# Update .netrc
	if ! grep -q "machine github.com" "$netrc_path" 2>/dev/null; then
		log "üìù Writing GitHub credentials to $netrc_path"
		cat <<EOF >>"$netrc_path"
machine github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine api.github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine raw.githubusercontent.com
  login $GITHUB_TOKEN
  password x-oauth-basic
EOF
		chmod 600 "$netrc_path"
		success "Added GITHUB TOKEN to $netrc_path"
	else
		warn "$netrc_path already contains GitHub credentials"
	fi

	# Add export to .bash_profile.local
	log "üìù Writing GITHUB_TOKEN to $BASH_PROFILE_LOCAL_FILE"
	if grep -q "GITHUB_TOKEN=" "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null; then
		warn "GITHUB_TOKEN already set in $BASH_PROFILE_LOCAL_FILE"
	else
		echo "export GITHUB_TOKEN=\"$GITHUB_TOKEN\"" >>"$BASH_PROFILE_LOCAL_FILE"
		success "Added GITHUB_TOKEN to $BASH_PROFILE_LOCAL_FILE"
	fi

	return 0
}

# Set up Git user.name and user.email from prompt if unset
setup_git_author() {
	log "üîé Checking if Git author name and email are setup..."

	if ! command -v git >/dev/null 2>&1; then
		error "Git is not installed. Skipping Git author setup"
		return 69 # git unavailable (EX_UNAVAILABLE)
	fi

	log "ü™™ Setting up Git author name and email"
	local current_name current_email input_name input_email
	current_name=$(git config --file "$GIT_CONFIG_FILE" user.name 2>/dev/null || echo "")
	current_email=$(git config --file "$GIT_CONFIG_FILE" user.email 2>/dev/null || echo "")

	if [[ -z "$current_name" ]]; then
		prompt_for input_name "üë§ Enter Git name [default: $GIT_AUTHOR_NAME]"
		input_name="${input_name:-$GIT_AUTHOR_NAME}"
		git config --file "$GIT_CONFIG_FILE" user.name "$input_name"
		success "Git name set to: $input_name"
	else
		info "Git name already set to: $current_name"
	fi

	if [[ -z "$current_email" ]]; then
		prompt_for input_email "‚úâÔ∏è Enter Git email [default: $GIT_AUTHOR_EMAIL]"
		input_email="${input_email:-$GIT_AUTHOR_EMAIL}"
		git config --file "$GIT_CONFIG_FILE" user.email "$input_email"
		success "Git email set to: $input_email"
	else
		info "Git email already set to: $current_email"
	fi

	log "üìù Writing Git author variables to $BASH_PROFILE_LOCAL_FILE"
	{
		grep -q '^export GIT_AUTHOR_NAME=' "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null || echo "export GIT_AUTHOR_NAME=\"$input_name\"" >>"$BASH_PROFILE_LOCAL_FILE"
		grep -q '^export GIT_AUTHOR_EMAIL=' "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null || echo "export GIT_AUTHOR_EMAIL=\"$input_email\"" >>"$BASH_PROFILE_LOCAL_FILE"
	} && success "Git author variables exported to $BASH_PROFILE_LOCAL_FILE"

	return 0
}

# Generate and configure a GPG key for Git commit signing
setup_gpg_key() {
	log "üîé Checking for GPG installation..."

	if ! command -v gpg &>/dev/null; then
		warn "GPG not found. Attempting to install via Homebrew..."

		if ! install_homebrew || ! run_quietly brew install gnupg; then
			error "Homebrew installation failed during GPG setup"
			return 69 # homebrew unavailable (EX_UNAVAILABLE)
		fi

		success "Installed GPG"
	fi

	export GNUPGHOME="${GNUPGHOME:-$HOME/.config/gnupg}"
	mkdir -p "$GNUPGHOME" || {
		error "Failed to create directory: $GNUPGHOME"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "üîí Securing GPG directory permissions..."
	chmod 700 "$GNUPGHOME"
	find "$GNUPGHOME" -type f -exec chmod 600 {} \;

	log "üîë Generating and configuring GPG key..."
	local gpg_key
	gpg_key=$(run_quietly gpg --list-secret-keys --keyid-format LONG 2>/dev/null | awk '/sec/{print $2}' | awk -F'/' '{print $2}' | head -n1)

	if [[ -z "$gpg_key" ]]; then
		log "üîß No GPG key found ‚Äî generating one now (interactive)..."
		gpg --gen-key || {
			error "GPG key generation failed"
			return 70
		}
		gpg_key=$(run_quietly gpg --list-secret-keys --keyid-format LONG | awk '/sec/{print $2}' | awk -F'/' '{print $2}' | head -n1)
	fi

	if [[ -z "$gpg_key" ]]; then
		error "Failed to find or generate GPG key"
		return 67 # Missing user input (EX_NOUSER)
	fi

	log "üîó Setting Git signing key to: $gpg_key"
	git config --file "$GIT_CONFIG_FILE" user.signingkey "$gpg_key"

	local tmp_export_file
	tmp_export_file="$(mktemp "/tmp/gpg-key-${gpg_key}.XXXXXX.asc")"
	if gpg --armor --export "$gpg_key" >"$tmp_export_file"; then
		info "üìÑ GPG public key exported to: $tmp_export_file"
		log "üîó pbcopy the contents and add this GPG key to GitHub: https://github.com/settings/keys"
	else
		error "Failed to export GPG key."
		return 74 # Export failed (EX_IOERR)
	fi

	success "GPG setup and directory permissions secured."

	return 0
}

generate_gpg_key() {
	log "üîë Generating GPG key (non-interactively)..."

	# Create GPG config directory
	export GNUPGHOME="${GNUPGHOME:-$HOME/.config/gnupg}"
	mkdir -p "$GNUPGHOME"
	chmod 700 "$GNUPGHOME"
	[[ "${DEBUG:-false}" == "true" ]] && find "$GNUPGHOME"

	local gpg_batch
	gpg_batch=$(mktemp)

	# Create batch file for key generation
	cat <<EOF >"$gpg_batch"
%no-protection
Key-Type: RSA
Key-Length: 4096
Name-Real: $GIT_AUTHOR_NAME
Name-Email: $GIT_AUTHOR_EMAIL
Expire-Date: 0
%commit
EOF

	# Generate key
	if run_quietly gpg --batch --generate-key "$gpg_batch"; then
		chmod 700 "$GNUPGHOME"
		success "GPG key generated for $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>"
	else
		error "Failed to generate GPG key"
		rm -f "$gpg_batch"
		return 70
	fi

	rm -f "$gpg_batch"

	# Display generated key info
	local key_output key_id
	key_output=$(gpg --list-secret-keys --with-colons "$GIT_AUTHOR_EMAIL" 2>/dev/null)
	key_id=$(echo "$key_output" | awk -F: '/^sec/ { print $5 }' | head -n1)

	if [[ -n "$key_id" ]]; then
		info "GPG Key ID: $key_id"
		git config --file "$GIT_CONFIG_FILE" user.signingkey "$key_id"

		# Export the public key
		local export_file
		export_file="$(mktemp "/tmp/${GIT_AUTHOR_EMAIL}_gpg_pub_XXXXXX.asc")"
		log "üîë Exporting GPG public key: $export_file"
		if gpg --armor --export "$GIT_AUTHOR_EMAIL" >"$export_file"; then
			info "GPG public key saved to: $export_file"
		else
			warn "Failed to export GPG public key"
		fi

		# Test signing
		if echo "test" | gpg --local-user "$key_id" --clearsign >/dev/null 2>&1; then
			success "GPG signing key configured for Git"
		else
			error "GPG key exists but signing test failed"
			return 71
		fi
	else
		warn "GPG key generated but could not extract key ID"
		[[ "${DEBUG:-false}" == "true" ]] && echo "$key_output"
	fi

	return 0
}

# Change the login shell to Homebrew Bash if needed
change_login_shell() {
	log "üîé Checking login shell..."

	local new_shell
	new_shell="$(brew --prefix)/bin/bash"
	if [[ "$SHELL" == "$new_shell" ]]; then
		info "Login shell already set to: $new_shell"
		return 0
	fi

	if [[ ! -x "$new_shell" ]]; then
		error "Target shell does not exist: $new_shell"
		return 66 # EX_NOINPUT
	fi

	if ! grep -Fxq "$new_shell" /etc/shells; then
		log "üìù Writing $new_shell to /etc/shells"

		if [[ "$OS" == "darwin" && -x "$(command -v sudo)" ]]; then
			if ! echo "$new_shell" | sudo tee -a /etc/shells >/dev/null; then
				error "Failed to add $new_shell to /etc/shells"
				return 71 # EX_OSERR
			fi
		elif [[ "$OS" == "linux" && -x "$(command -v sudo)" ]]; then
			if ! echo "$new_shell" | sudo tee -a /etc/shells >/dev/null; then
				error "Failed to add $new_shell to /etc/shells"
				return 71 # EX_OSERR
			fi
		else
			error "Cannot modify /etc/shells without sudo privileges"
			return 69 # EX_UNAVAILABLE
		fi
		success "Added $new_shell to /etc/shells"
	fi

	log "üêö Changing login shell to: $new_shell"
	if run_quietly sudo chsh -s "$new_shell" "${USER:-$(id -un)}"; then
		success "Login shell changed to: $new_shell"
	else
		error "Failed to change login shell"
		return 71 # EX_OSERR
	fi

	return 0
}

# Global tracking
start_time=""
end_time=""
# These steps are registered to track what should run
pending_steps=(
	install_homebrew
	extract_repo
	clone_repo
	symlink_binary
	symlink_dotconfigs
	symlink_os_files
	symlink_configs
	create_bash_profile_local
	install_homebrew_packages
	install_npm_packages
	install_whalebrew_packages
	install_macos_apps
	install_fonts
	install_warp_themes
	install_genmoji
	install_gitmoji_fuzzy_hook
	setup_fzf_keybindings
	setup_github_token
	setup_git_author
	generate_gpg_key
	change_login_shell
)
failed_steps=()

# Step management
complete_step() {
	local label="$1"
	local -a new_pending=() # ‚úÖ explicitly declare as array

	for step in "${pending_steps[@]}"; do
		if [[ "$step" != "$label" ]]; then
			new_pending+=("$step")
		fi
	done

	pending_steps=("${new_pending[@]}")
}

fail_step() {
	local label="$1"
	failed_steps+=("$label")
	complete_step "$label"
}

run_step() {
	local label="$1"
	shift

	if "$@"; then
		complete_step "$label"
	else
		fail_step "$label"
	fi
}

optional_step() {
	local label="$1"
	shift

	if "$@"; then
		complete_step "$label"
	else
		fail_step "$label"
	fi
}

# Cleanup trap
cleanup() {
	section "üöÄ dotfiles installation stats:"

	if [[ -n "$start_time" ]]; then
		end_time=$(date +%s)
		log "‚è±Ô∏è Completed in $((end_time - start_time)) seconds"
	else
		log "‚è±Ô∏è Exited before timing could begin"
	fi

	if [[ "${#failed_steps[@]}" -gt 0 ]]; then
		error "These steps failed:"
		for step in "${failed_steps[@]}"; do
			[[ -n "${step}" ]] && log "\t - $step"
		done
	fi

	if [[ "${#pending_steps[@]}" -gt 0 ]]; then
		warn "These steps were skipped or did not run:"
		for step in "${pending_steps[@]}"; do
			[[ -n "${step// /}" ]] && log "\t - $step"
		done
	fi
}

trap cleanup EXIT

main() {
	start_time=$(date +%s)

	# print out the banner, no matter what happens on setup
	print_banner
	# print out computer stats that are useful
	print_stats

	# Set up logging first ‚Äî before any log messages
	init_log_file || echo "‚ö†Ô∏è Log file could not be initialized"

	header "üöÄ Starting dotfiles installation..."

	section "üß± Setting up dependencies, cloning library and installing binary"
	run_step "install_homebrew" install_homebrew
	run_step "extract_repo" extract_repo
	run_step "clone_repo" clone_repo
	run_step "symlink_binary" symlink_binary
	success "${REPO} cloned, setup, and binary installed" "true"

	section "‚öôÔ∏è Setting up configurations"
	run_step "symlink_dotconfigs" symlink_dotconfigs
	run_step "symlink_os_files" symlink_os_files
	run_step "symlink_configs" symlink_configs
	run_step "create_bash_profile_local" create_bash_profile_local
	success "Configurations are setup" "true"

	section "üì¶ Installing and setting up tools"
	run_step "install_homebrew_packages" install_homebrew_packages
	run_step "install_npm_packages" install_npm_packages
	optional_step "install_whalebrew_packages" install_whalebrew_packages
	optional_step "install_macos_apps" install_macos_apps
	optional_step "install_fonts" install_fonts
	# optional_step "install_ls_colors" install_ls_colors
	optional_step "install_warp_themes" install_warp_themes
	optional_step "install_genmoji" install_genmoji
	optional_step "install_gitmoji_fuzzy_hook" install_gitmoji_fuzzy_hook
	optional_step "setup_fzf_keybindings" setup_fzf_keybindings
	success "Tools are installed and setup" "true"

	#  Tool setup
	section "üîß Configure authorship"
	run_step "setup_github_token" setup_github_token
	run_step "setup_git_author" setup_git_author
	run_step "generate_gpg_key" generate_gpg_key
	run_step "change_login_shell" change_login_shell
	success "Authorship is configured" "true"

	echo -e "${LOG_PREFIX}:"
	success "${REPO} installed. Open a new terminal session" "true"
}

main

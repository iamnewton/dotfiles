#!/usr/bin/env bash
set -euo pipefail

# Set default permissions for new files and directories to 755/644
# Ensures created files are owner-writable, but not group/world-writable (e.g., ~/.ssh, ~/.config)
# Helps avoid accidentally creating insecure or overly permissive files
umask 022

# Constants
readonly OS="$(uname | tr '[:upper:]' '[:lower:]')"

# User variables
readonly USERNAME="iamnewton"
readonly REPO="dotfiles"
readonly INSTALL_DIR="$HOME/.local/lib/$REPO"

readonly GIT_AUTHOR_NAME="${GIT_AUTHOR_NAME:-Newton}"
readonly GIT_AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-5769156+iamnewton@users.noreply.github.com}"
readonly GIT_CONFIG_FILE="$HOME/.config/git/local"
readonly BASH_PROFILE_LOCAL_FILE="$HOME/.bash_profile.local"

# ANSI color codes
readonly CYAN="\033[36m"
readonly PURPLE="\033[1;35m"
readonly RED="\033[1;31m"
readonly GREEN="\033[1;32m"
readonly YELLOW="\033[1;33m"
readonly BLUE="\033[1;34m"
readonly DIM_WHITE="\033[2;37m"
readonly BOLD_WHITE="\033[1;97m"
readonly BRIGHT_WHITE="\033[97m"
readonly UNDERLINE="\033[4m"
readonly RESET="\033[0m"
readonly LOG_PREFIX="${PURPLE}[${REPO}]${RESET}"

# Logging destinations
readonly LOG_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/dotfiles/install.log"
readonly LOG_TO_FILE="${DOTFILES_LOG_TO_FILE:-true}"
readonly LOG_TO_SYSLOG="${DOTFILES_LOG_TO_SYSLOG:-true}"

# print out some fun header
# @url: https://patorjk.com/software/taag/#p=testall&h=1&v=1&f=Doh&t=dotfiles
print_banner() {
	cat <<'EOF'


            dddddddd
            d::::::d                          tttt             ffffffffffffffff    iiii  lllllll
            d::::::d                       ttt:::t            f::::::::::::::::f  i::::i l:::::l
            d::::::d                       t:::::t           f::::::::::::::::::f  iiii  l:::::l
            d:::::d                        t:::::t           f::::::fffffff:::::f        l:::::l
    ddddddddd:::::d    ooooooooooo   ttttttt:::::ttttttt     f:::::f       ffffffiiiiiii  l::::l     eeeeeeeeeeee        ssssssssss
  dd::::::::::::::d  oo:::::::::::oo t:::::::::::::::::t     f:::::f             i:::::i  l::::l   ee::::::::::::ee    ss::::::::::s
 d::::::::::::::::d o:::::::::::::::ot:::::::::::::::::t    f:::::::ffffff        i::::i  l::::l  e::::::eeeee:::::eess:::::::::::::s
d:::::::ddddd:::::d o:::::ooooo:::::otttttt:::::::tttttt    f::::::::::::f        i::::i  l::::l e::::::e     e:::::es::::::ssss:::::s
d::::::d    d:::::d o::::o     o::::o      t:::::t          f::::::::::::f        i::::i  l::::l e:::::::eeeee::::::e s:::::s  ssssss
d:::::d     d:::::d o::::o     o::::o      t:::::t          f:::::::ffffff        i::::i  l::::l e:::::::::::::::::e    s::::::s
d:::::d     d:::::d o::::o     o::::o      t:::::t           f:::::f              i::::i  l::::l e::::::eeeeeeeeeee        s::::::s
d:::::d     d:::::d o::::o     o::::o      t:::::t    tttttt f:::::f              i::::i  l::::l e:::::::e           ssssss   s:::::s
d::::::ddddd::::::ddo:::::ooooo:::::o      t::::::tttt:::::tf:::::::f            i::::::il::::::le::::::::e          s:::::ssss::::::s
 d:::::::::::::::::do:::::::::::::::o      tt::::::::::::::tf:::::::f            i::::::il::::::l e::::::::eeeeeeee  s::::::::::::::s
  d:::::::::ddd::::d oo:::::::::::oo         tt:::::::::::ttf:::::::f            i::::::il::::::l  ee:::::::::::::e   s:::::::::::ss
   ddddddddd   ddddd   ooooooooooo             ttttttttttt  fffffffff            iiiiiiiillllllll    eeeeeeeeeeeeee    sssssssssss


EOF
}

# print out some stats about the machine/installer
print_stats() {
	echo "🖥️  Host:"
	echo "    Hostname:    $(hostname)"
	if command -v sw_vers &>/dev/null; then
		echo "    OS Version:  $(sw_vers -productName) $(sw_vers -productVersion)"
	else
		echo "    OS Release:  $(lsb_release -d 2>/dev/null | cut -f2-)$(grep PRETTY_NAME /etc/os-release | cut -d= -f2-)"
	fi
	echo "    Kernel:      $(uname -sr)"
	echo

	echo "🐚 Shell & User:"
	echo "    User:        $(whoami)"
	echo "    Shell:       $(ps -p $$ -o comm=) ($(basename $SHELL))"
	echo

	echo "💾 Disk Usage:"
	echo "    Root:        $(df -h / | awk 'NR==2 { printf "%s used, %s free\n", $3, $4 }')"
	echo "    Home:        $(df -h "$HOME" | awk 'NR==2 { printf "%s used, %s free\n", $3, $4 }')"
	echo

	echo "🌐 Network:"
	echo "    Local IP:    $(hostname -I 2>/dev/null || ipconfig getifaddr en0 2>/dev/null || echo unknown)"
	echo "    Public IP:   $(curl -s ifconfig.me || echo unknown)"
	echo
}

# Internal helper: log to file if enabled
_log_to_file() {
	local level="$1"
	local msg="$2"
	echo "[$(date '+%Y-%m-%d %H:%M:%S')][$level] $msg" >>"$LOG_FILE"
}

# Internal helper: send to macOS Console.app if enabled
_log_to_syslog() {
	[[ "$OS" != "darwin" ]] && return 0
	command -v logger >/dev/null || return 0
	local msg="$1"
	logger -t $REPO "$msg"
}

# Suppress command output to stdout but log elsewhere
run_quietly() {
	local output cmd="$*"
	output="$("$@" 2>&1)" || {
		_log_to_file "ERROR" "$cmd"
		_log_to_syslog "[ERROR] $cmd"
		[[ "${DEBUG:-false}" == "true" ]] && echo "$output"
		return 1
	}

	_log_to_file "INFO" "$cmd"
	_log_to_syslog "[INFO] $cmd"
	[[ "${DEBUG:-false}" == "true" ]] && echo "$output"
	return 0
}

# Logging functions
log() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t${DIM_WHITE}${msg}${RESET}"
	_log_to_file "LOG" "$msg"
	_log_to_syslog "$msg"
}

header() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: ${BRIGHT_WHITE}${msg}${RESET}"
}

section() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}:"
	echo -e "${LOG_PREFIX}: ${BOLD_WHITE}${msg}${RESET}"
}

info() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \tℹ️ ${BLUE}${msg}${RESET}"
	_log_to_file "INFO" "$msg"
	_log_to_syslog "[INFO] $msg"
}

warn() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t⚠️ ${YELLOW}${msg}${RESET}"
	_log_to_file "WARN" "$msg"
	_log_to_syslog "[WARN] $msg"
}

error() {
	local msg="${1:-}"
	echo -e "${LOG_PREFIX}: \t❌ ${RED}${msg}${RESET}" >&2
	_log_to_file "ERROR" "$msg"
	_log_to_syslog "[ERROR] $msg"
}

success() {
	local msg="${1:-}"
	local is_final="${2:-false}"

	local prefix="${LOG_PREFIX}:\t"
	if [[ "$is_final" == "true" ]]; then
		prefix="${LOG_PREFIX}: "
	fi

	echo -e "${prefix}${GREEN}✅ ${msg}${RESET}"
	_log_to_file "SUCCESS" "$msg"
	_log_to_syslog "[SUCCESS] $msg"
}

# ─── prompt_for Function ────────────────────────────────────────────────────────
# prompt_for <VAR_NAME> <PROMPT_MESSAGE>
#  • If $VAR_NAME is already non-empty, skips prompt.
#  • If running under CI (CI or GITHUB_ACTIONS env), skips prompt.
#  • Otherwise, does a colored interactive read into $VAR_NAME.
prompt_for() {
	local varname="$1"
	local message="$2"

	local cyan=$'\033[36m'
	local reset=$'\033[0m'
	local tab=$'\t'
	local log_prefix=$'\033[1;35m[${repo}]\033[0m'

	# safe indirect expansion: defaults to empty if unset
	local current="${!varname:-}"

	if [[ -n "$current" ]]; then
		info "${message} (already set)"
		return 0
	fi

	if [[ -n "${CI-}" || -n "${GITHUB_ACTIONS-}" ]]; then
		info "${message} (skipping prompt in CI)"
		return
	fi

	read -rp "${log_prefix}:${tab}${cyan}${message}:${reset} " "$varname"
}

# Ensure log dir exists
init_log_file() {
	mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || {
		warn "Failed to create log directory: $(dirname "$LOG_FILE")"
		return 1
	}

	touch "$LOG_FILE" 2>/dev/null || {
		warn "Failed to create log file: $LOG_FILE"
		return 1
	}
}

# Install Homebrew if missing and activate its shell environment
install_homebrew() {
	log "🔎 Checking for Homebrew..."

	if ! command -v brew >/dev/null 2>&1; then
		log "🍺 Installing Homebrew"

		if [[ -n "${CI:-}" || -n "${DOTFILES_NONINTERACTIVE:-}" || ! -t 1 ]]; then
			if ! NONINTERACTIVE=1 run_quietly /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
				error "Homebrew installation failed (non-interactive)"
				return 74
			fi
		else
			if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
				error "Homebrew installation failed"
				return 74
			fi
		fi

		# Find the installed brew binary
		local brew_bin
		for path in /opt/homebrew/bin/brew /usr/local/bin/brew /home/linuxbrew/.linuxbrew/bin/brew; do
			if [[ -x "$path" ]]; then
				brew_bin="$path"
				break
			fi
		done

		if [[ -z "${brew_bin:-}" ]]; then
			error "Failed to find installed brew binary"
			return 70 # EX_SOFTWARE
		fi

		# Shellenv activation
		log "🔧 Configuring Homebrew environment"
		eval "$("$brew_bin" shellenv)" || {
			error "Failed to configure Homebrew environment"
			return 70
		}

		success "Homebrew installed and configured"
		return 0
	fi

	log "🔧 Configuring Homebrew environment"
	if ! eval "$(brew shellenv)"; then
		error "Failed to configure Homebrew environment"
		return 70 # Internal shell eval/config error (EX_SOFTWARE)
	fi

	info "Homebrew is already installed"

	return 0
}

# Download dotfiles repo and extract it to the install directory
extract_repo() {
	log "🔎 Checking for $INSTALL_DIR..."

	if [[ -d "$INSTALL_DIR" && -n "$(ls -A "$INSTALL_DIR")" ]]; then
		info "$INSTALL_DIR already exists and is not empty. Skipping extraction"
		success "Using previously extracted dotfiles"
		return 0
	fi

	mkdir -p "$INSTALL_DIR" || {
		error "Failed to create directory: $INSTALL_DIR"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "📥 Downloading $REPO"
	if ! curl -fsSL "https://github.com/$USERNAME/$REPO/tarball/main" | tar -xz --strip-components=1 -C "$INSTALL_DIR"; then
		error "Failed to extract $REPO to $INSTALL_DIR"
		return 74 # I/O error from curl or tar (EX_IOERR)
	fi

	success "Downloaded & extracted $REPO to $INSTALL_DIR"
	return 0
}

# Clone or reinitialize the dotfiles repository in the install directory
clone_repo() {
	log "🔎 Checking if $INSTALL_DIR is already initialized and up-to-date..."

	if [[ ! -d "$INSTALL_DIR" ]]; then
		mkdir -p "$INSTALL_DIR" || {
			error "Failed to create directory: $INSTALL_DIR"
			return 73 # Can't create directory (EX_CANTCREAT)
		}
	fi

	if ! pushd "$INSTALL_DIR" >/dev/null; then
		error "Failed to enter directory: $INSTALL_DIR"
		return 73 # Can't create directory (EX_CANTCREAT)
	fi

	# If repo already initialized, check if it's clean and up-to-date
	local repo_url
	repo_url="https://github.com/${USERNAME}/${REPO}.git"
	if [[ -d .git ]]; then
		local remote_url branch
		remote_url="$(git remote get-url origin 2>/dev/null || true)"
		branch="$(git symbolic-ref --short HEAD 2>/dev/null || echo '')"

		if git diff --quiet && git diff --cached --quiet && [[ "$remote_url" == "$repo_url" ]] && [[ "$branch" =~ ^(main|master)$ ]]; then
			info "Dotfiles repo already cloned, clean, and on $branch"
			popd >/dev/null
			return 0
		fi

		if [[ -n "$(git status --porcelain)" ]]; then
			warn "⚠️ Uncommitted changes detected: stashing them before reset"
			git stash push -u -m "dotfiles-auto-stash-before-reset" || warn "Stash failed"
			info "Your previous changes were stashed. Use \`git stash list\` to review or \`git stash pop\` to restore."
		fi
	else
		log "🆕 Initializing new Git repository"
		run_quietly git init --initial-branch=main || {
			error "Failed to initialize git repository"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}

		log "🔧 Configuring default branch: main"
		git branch -m main || {
			error "Failed to rename default branch to main"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}
	fi

	log "🔧 Configuring remote origin: $repo_url"
	if ! git remote | grep -q "^origin$"; then
		git remote add origin "$repo_url" || {
			error "Failed to add remote origin"
			popd >/dev/null
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		}
	else
		info "Remote origin already exists"
	fi

	log "📥 Fetching origin/main"
	if ! run_quietly git fetch origin main; then
		error "Failed to fetch from origin"
		popd >/dev/null
		return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
	fi

	log "🧹 Resetting index and working tree to origin/main"
	local head
	if ! head=$(git reset --hard FETCH_HEAD 2>&1); then
		error "Failed to reset to FETCH_HEAD"
		popd >/dev/null
		return 70 # Software error
	fi
	info "$head"

	log "🧽 Cleaning untracked files"
	git clean -fd || warn "Git clean produced warnings"

	success "Repository has been initialized and reset to origin/main"

	log "📤 Pulling latest changes (rebase)"
	if ! run_quietly git pull --rebase origin main; then
		error "Failed to pull latest changes"
		popd >/dev/null
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	log "🔄 Updating submodules"
	if ! git submodule update --recursive --init --quiet; then
		error "Failed to update submodules"
		popd >/dev/null
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	popd >/dev/null
	success "Repository is up to date"
	return 0
}

# Symlink the main repo binary
symlink_binary() {
	local filepath target
	filepath="$INSTALL_DIR/bin/${REPO}"
	target="$HOME/.local/bin/$REPO"
	log "🔎 Checking for binary at $HOME/.local/bin/$REPO..."

	if [[ "$(readlink "$target")" == "$filepath" ]]; then
		info "Binary already exists: $target → $filepath"
		success "Using existing binary"
		return 0
	fi

	if [[ ! -x "$filepath" ]]; then
		error "Binary not found or not executable: $filepath"
		return 66 # Input file missing or not executable (EX_NOINPUT)
	fi

	mkdir -p "$(dirname "$target")" || {
		error "Failed to create directory: $(dirname "$target")"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "🔗 Symlinking binary"
	if ln -sfn "$filepath" "$target"; then
		success "Symlinked binary $filepath → $target"
	else
		error "Failed to symlink binary from $filepath to $target"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	return 0
}

# Symlink files from conf/ into dot-prefixed files in $HOME
symlink_dotconfigs() {
	log "🔎 Checking for dotconfig symlinks..."

	local source_dir
	source_dir="${INSTALL_DIR}/conf"
	if [[ ! -d "$source_dir" ]]; then
		error "Directory not found: $source_dir"
		return 66 # Source directory not found (EX_NOINPUT)
	fi

	log "🔗 Symlinking dotconfig files to HOME directory"
	local count=0
	for filepath in "$source_dir"/*; do
		[[ -f "$filepath" ]] || continue

		local filename target
		filename="$(basename "$filepath")"
		target="$HOME/.$filename"

		# Remove existing file or broken symlink if it's not a symlink
		if [[ -e "$target" && ! -L "$target" ]]; then
			log "📁 Removing existing file: $target"
			rm -f "$target" || {
				error "Failed to remove existing file: $target"
				continue
			}
		fi

		log "🔗 Symlinking $filename"
		if ln -sfn "$filepath" "$target"; then
			success "Symlinked $filepath → $target"
			((count++))
		else
			error "Failed to symlink from $filepath to $target"
			return 70 # Symlink failed (EX_SOFTWARE)
		fi
	done

	if [[ "$count" -eq 0 ]]; then
		warn "No dotfiles were symlinked from $source_dir"
	else
		info "Symlinked $count dotfile(s) from $source_dir"
	fi

	return 0
}

# Symlink OS-specific config files based on `uname`
symlink_os_files() {
	log "🔎 Checking for OS-specific configuration symlinks..."

	local base_dir
	base_dir="${INSTALL_DIR}/lib"
	if [[ ! -d "$base_dir" ]]; then
		error "Directory does not exist: $base_dir"
		return 66 # Directory not found (EX_NOINPUT)
	fi

	log "🔗 Symlinking OS-specific configs: $OS"
	local -a targets=("ssh" "tmux")
	local processed=0

	for sub in "${targets[@]}"; do
		local os_file="$base_dir/$sub/$OS"

		if [[ ! -f "$os_file" ]]; then
			info "No $OS config found in $sub/"
			continue
		fi

		case "$sub" in
		ssh)
			local target="$HOME/.ssh/config"
			log "🔗 Copying $os_file"
			mkdir -p "$(dirname "$target")" || {
				error "Failed to create directory: $(dirname "$target")"
				continue
			}
			if cp "$os_file" "$target"; then
				success "Copied $os_file → $target"
				((processed++))
			else
				error "Failed to copy from $os_file to $target"
			fi
			;;
		tmux)
			local target="$HOME/.tmux.conf"
			log "🔗 Symlinking $os_file"
			if ln -sfn "$os_file" "$target"; then
				success "Symlinked $os_file → $target"
				((processed++))
			else
				error "Failed to symlink from $os_file to $target"
			fi
			;;
		*)
			warn "Skipping unsupported config type: $sub"
			continue
			;;
		esac
	done

	if [[ "$processed" -gt 0 ]]; then
		info "Processed $processed OS-specific config(s):$OS"
	else
		info "No OS-specific configs were symlinked: $OS"
	fi

	success "Symlinked OS-specific configs: $OS"
	return 0
}

# Symlink app configs from share/config into ~/.config/
symlink_configs() {
	log "🔎 Checking app config symlinks to $HOME/.config..."

	local source_dir target_dir
	source_dir="$INSTALL_DIR/share/config"
	if [[ ! -d "$source_dir" ]]; then
		error "Source config directory does not exist: $source_dir"
		return 66 # Directory not found (EX_NOINPUT)
	fi

	target_dir="$HOME/.config"
	mkdir -p "$target_dir" || {
		error "Failed to create directory: $target_dir"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	local count=0
	for item in "$source_dir"/*; do
		[[ -e "$item" ]] || continue
		local name target
		name="$(basename "$item")"
		target="$target_dir/$name"

		# Remove existing non-symlink to avoid failure
		if [[ -e "$target" && ! -L "$target" ]]; then
			warn "Removing existing non-symlink: $target"
			rm -rf "$target"
		fi

		log "🔗 Symlinking $name"
		if ln -sfn "$item" "$target"; then
			success "Symlinked $name → $target"
			((count++))
		else
			error "Failed to symlink from $item to $target"
		fi
	done

	if [[ "$count" -eq 0 ]]; then
		warn "No configs were symlinked from $source_dir"
	else
		info "Symlinked $count config(s) into $HOME/.config/"
	fi

	return 0
}

# Create a local bash profile file and set DOTFILES_DIR if not present
create_bash_profile_local() {
	log "🔎 Checking if $BASH_PROFILE_LOCAL_FILE exists..."

	local profile_file="$HOME/.bash_profile"
	local export_line="export DOTFILES_DIR=\"$INSTALL_DIR\""

	# Ensure the .bash_profile.local file exists
	if [[ ! -f "$BASH_PROFILE_LOCAL_FILE" ]]; then
		log "🆕 Creating .bash_profile.local"
		echo '#!/usr/bin/env bash' >"$BASH_PROFILE_LOCAL_FILE"
		success "Created $BASH_PROFILE_LOCAL_FILE"
	else
		info "$BASH_PROFILE_LOCAL_FILE already exists"
	fi

	# Ensure it's sourced in .bash_profile
	log "📝 Writing source line to $profile_file"
	if [[ -f "$BASH_PROFILE_LOCAL_FILE" ]]; then
		if ! grep -qF "$BASH_PROFILE_LOCAL_FILE" "$profile_file"; then
			echo "[[ -f $BASH_PROFILE_LOCAL_FILE ]] && source $BASH_PROFILE_LOCAL_FILE" >>"$profile_file"
			success "Added source line to $profile_file"
		else
			info "$profile_file already sources $BASH_PROFILE_LOCAL_FILE"
		fi
	else
		warn "$profile_file not found — skipping source line injection"
	fi

	log "📝 Writing DOTFILES_DIR to $BASH_PROFILE_LOCAL_FILE"
	# Add DOTFILES_DIR if not already present
	if ! grep -E "^export DOTFILES_DIR=" "$BASH_PROFILE_LOCAL_FILE" >/dev/null 2>&1; then
		echo "$export_line" >>"$BASH_PROFILE_LOCAL_FILE"
		success "Added DOTFILES_DIR to $BASH_PROFILE_LOCAL_FILE"
	else
		info "DOTFILES_DIR already defined in $BASH_PROFILE_LOCAL_FILE"
	fi

	return 0
}

# Install packages via Brewfile
install_homebrew_packages() {
	log "🔎 Checking for Homebrew..."

	if ! command -v brew >/dev/null 2>&1; then
		warn "Homebrew not found. Attempting to reinstall Homebrew"

		if ! install_homebrew; then
			error "Failed to install Homebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		success "Installed Homebrew"
	fi

	local brewfile_path
	brewfile_path="$INSTALL_DIR/lib/homebrew/Brewfile"
	if [[ ! -f "$brewfile_path" ]]; then
		error "No Brewfile found in repo: $brewfile_path"
		return 66 # Input file not found (EX_NOINPUT)
	fi

	log "🍺 Installing Homebrew packages from Brewfile"
	local bundle_log
	bundle_log="$(mktemp)"
	if ! run_quietly brew bundle --file="$brewfile_path"; then
		warn "Failed to install packages via Brewfile"
	else
		success "Installed all Homebrew packages"
	fi

	# Parse and list failed packages
	local failed=()
	while IFS= read -r line; do
		if [[ "$line" =~ ^Error:\ (.*)\!$ ]]; then
			local message="${BASH_REMATCH[1]}"
			# Try to extract the package name
			if [[ "$message" =~ install\ ([a-z0-9@._+-]+) ]]; then
				failed+=("${BASH_REMATCH[1]}")
			fi
		fi
	done <"$bundle_log"

	if ((${#failed[@]})); then
		warn "The following packages failed to install and may need to be installed manually:"
		for pkg in "${failed[@]}"; do
			echo "  - $pkg"
		done
	fi

	rm -f "$bundle_log"

	return 0
}

# Install or update Whalebrew Docker-based CLIs
install_whalebrew_packages() {
	log "🔎 Checking if Whalebrew is supported..."

	if [[ -n "${CI:-}" ]]; then
		info "Running in CI environment. Skipping Whalebrew."
		return 0
	fi

	if ! command -v docker >/dev/null && ! command -v podman >/dev/null; then
		warn "Neither Docker nor Podman is available. Skipping Whalebrew."
		return 0
	fi

	if [[ "$OS" != "darwin" ]]; then
		warn "Whalebrew is only supported on macOS. Skipping installation on: $OS"
		return 0
	fi

	if ! command -v whalebrew >/dev/null 2>&1; then
		warn "whalebrew not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! brew install whalebrew; then
			error "Failed to install whalebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		success "Installed whalebrew"
	fi

	log "🐳 Installing/updating Whalebrew packages"
	local images
	images=(whalebrew/ffmpeg whalebrew/httpie whalebrew/speedtest whalebrew/youtube-dl)
	for image in "${images[@]}"; do
		local name
		name=$(basename "$image")

		if whalebrew list | grep -q "^$name$"; then
			info "🔄 Reinstalling $name..."
			whalebrew uninstall "$name"
		fi

		if whalebrew install "$image"; then
			success "Installed $name"
		else
			warn "Failed to install $name"
		fi
	done

	success "Whalebrew packages installed or updated"
	return 0
}

# Install or update global npm packages
install_npm_packages() {
	log "🔎 Checking for Node.js (npm)..."

	if ! command -v npm >/dev/null 2>&1 || ! command -v node >/dev/null 2>&1; then
		warn "npm not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! brew install node; then
			warn "Failed to install Node.js (npm)"
			return 74
		fi

		success "Installed Node.js (npm)"
	fi

	log "📦 Installing global npm packages"
	local packages
	packages=(
		"fkill-cli:fkill"
		"fx-completion:fx"
		"is-up-cli:is-up"
		"tldr:tldr"
		"trash-cli:trash"
		"vtop:vtop"
	)
	for pair in "${packages[@]}"; do
		IFS=":" read -r pkg cmd <<<"$pair"
		if npm list -g --depth=0 "$pkg" >/dev/null 2>&1; then
			info "🔄 Updating $cmd"
			run_quietly npm update --global --quiet "$pkg" || warn "Failed to update $pkg"
		else
			log "📦 Installing $cmd"
			run_quietly npm install --global --quiet "$pkg" || warn "Failed to install $pkg"
		fi

		if command -v "$cmd" >/dev/null 2>&1; then
			success "'$cmd' installed and available"
		else
			warn "'$cmd' not found in PATH after installing $pkg"
		fi
	done

	success "All npm packages installed or updated"
	return 0
}

# Prompt to install macOS App Store apps via mas and Brewfile.macos
install_macos_apps() {
	log "🔎 Checking if on MacOS for app installation..."

	if [[ -n "${CI:-}" ]]; then
		info "Running in CI environment. Skipping macOS app install"
		return 0
	fi

	if [[ "$OS" != "darwin" ]]; then
		warn "Not on macOS, skipping macOS app install"
		return 0
	fi

	local install_macos_apps_reply=""
	prompt_for install_macos_apps_reply "🖥 Install macOS apps too? (y/n)"
	# Use the env var value if already set
	install_macos_apps_reply="${install_macos_apps_reply:-${DOTFILES_MACOS_APPS:-n}}"

	if [[ ! "$install_macos_apps_reply" =~ ^[Yy]$ ]]; then
		info "You answered no. Skipping macOS app installation"
		return 0
	fi

	if ! command -v brew >/dev/null 2>&1; then
		warn "Homebrew not found. Installing"
		if ! install_homebrew || ! brew install mas; then
			warn "Failed to install macOS App Store CLI. Skipping app installations"
			return 74
		fi
	fi

	local brewfile_macos_path
	brewfile_macos_path="$INSTALL_DIR/lib/homebrew/Brewfile.macos"
	if [[ ! -f "$brewfile_macos_path" ]]; then
		error "Brewfile.macos not found at: $brewfile_macos_path"
		return 66 # Input file not found (EX_NOINPUT)
	fi

	log "🍏 Installing macOS apps from Brewfile.macos..."
	if brew bundle --file="$brewfile_macos_path"; then
		success "Installed macOS apps from Brewfile.macos"
	else
		error "Failed to install apps from Brewfile.macos"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	return 0
}

# Install custom TTF font included in the repo
install_fonts() {
	log "🔎 Checking for font files..."

	local font_dir font_name target
	font_dir="$INSTALL_DIR/lib/fonts"
	font_name="InputMonoCondensed Nerd Font.ttf"

	if [[ ! -f "$font_dir/$font_name" ]]; then
		error "Font file not found: $font_dir/$font_name"
		return 66 # Input file missing (EX_NOINPUT)
	fi

	if [[ "$OS" == "darwin" ]]; then
		target="$HOME/Library/Fonts"
	elif [[ "$OS" == "linux" ]]; then
		target="$HOME/.local/share/fonts"
	else
		warn "Unsupported OS for font installation"
		return 0
	fi

	log "🖋 Installing font to $target..."
	mkdir -p "$target" || {
		error "Failed to create font directory: $target"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	cp "$font_dir/$font_name" "$target" || {
		error "Failed to copy font to $target"
		return 74 # I/O error downloading or extracting (EX_IOERR)
	}

	if [[ "$OS" == "linux" ]]; then
		fc-cache -f "$target"
	fi

	success "Font '$font_name' installed"
	return 0
}

# Set up dircolors config (LS_COLORS)
install_ls_colors() {
	log "🔎 Checking if dircolors is setup..."

	if [[ -f "$HOME/.config/dircolors" ]]; then
		info "📁 LS_COLORS already installed."
		return 0
	fi

	if ! command -v dircolors &>/dev/null; then
		warn "dircolors not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! run_quietly brew install coreutils; then
			error "Failed to install Homebrew"
			return 74 # I/O error: failed to fetch or run install script (EX_IOERR)
		fi

		# Try to add the coreutils gnubin path
		local coreutils_path="$(brew --prefix)/opt/coreutils/libexec/gnubin"
		if [[ -x "$coreutils_path/dircolors" ]]; then
			export PATH="$coreutils_path:$PATH"
			info "Added $coreutils_path to PATH"
		fi

		success "Installed dircolors via coreutils via Homebrew"
	fi

	local tmp_dir repo_url
	tmp_dir="$(mktemp -d "/tmp/LS_COLORS.XXXXXX")"
	repo_url="https://github.com/trapd00r/LS_COLORS"

	log "📥 Downloading dircolors"
	if ! curl -fsSL --netrc-optional "$repo_url/tarball/master" | tar -xz --strip-components=1 -C "$tmp_dir"; then
		error "Failed to download or extract tarball from $repo_url"
		rm -rf "$tmp_dir"
		return 74 # I/O error downloading or extracting (EX_IOERR)
	fi

	log "🌈 Installing dircolors from LS_COLORS"
	if [[ -f "$tmp_dir/LS_COLORS" ]]; then
		dircolors -b "$tmp_dir/LS_COLORS" >"$HOME/.config/dircolors"
		success "Installed LS_COLORS to $HOME/.config/dircolors"
	else
		error "LS_COLORS file not found in extracted tarball."
		rm -rf "$tmp_dir"
		return 66 # Input file missing (EX_NOINPUT)
	fi

	rm -rf "$tmp_dir"
	return 0
}

# Install Genmoji (https://github.com/segersniels/genmoji)
install_genmoji() {
	log "🔎 Checking if Genmoji is installed..."

	if [[ "$(uname -m)" != "x86_64" ]]; then
		warn "Genmoji only supports x86_64 architectures; current architecture: "$(uname -m)". Skipping install."
		return 0
	fi

	local install_url install_target install_repo
	install_repo="genmoji"
	install_url="https://raw.githubusercontent.com/segersniels/${install_repo}/master/scripts/install.sh"
	install_dir="$HOME/.local/lib/$install_repo"
	install_target="$HOME/.local/bin"

	# Check if already installed
	if command -v genmoji >/dev/null 2>&1; then
		info "Genmoji is already installed at: $(command -v genmoji)"
		return 0
	else
		mkdir -p "$install_dir" || {
			error "Failed to create target directory: $install_dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}

		log "📥 Downloading Genmoji"
		if run_quietly curl -fsSL --netrc-optional "$install_url" | bash -s "$install_dir"; then
			success "Genmoji downloaded to $install_dir"
		else
			error "Failed to install Genmoji"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi

		log "🎭 Installing Genmoji to: $install_dir"
		log "🔗 Symlinking $install_dir → $install_target/$install_repo"
		if ln -sfn "$install_dir" "$install_target/$install_repo"; then
			success "Symlinked $install_dir → $install_target/$install_repo"
		else
			error "Failed to symlink $install_dir to $install_target/$install_repo"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi
	fi

	# Prompt for OpenAI API key
	local openai_api_key_input
	if [[ -n "${OPENAI_API_KEY:-}" ]]; then
		info "Using OPENAI_API_KEY from environment"
		openai_api_key_input="$OPENAI_API_KEY"
	else
		prompt_for openai_api_key_input "🔑 Enter your OpenAI API key (check Passwords app)"
	fi

	# Only export if a value was entered
	if [[ -n "$openai_api_key_input" ]]; then
		export OPENAI_API_KEY="$openai_api_key_input"

		# Add to bash_profile.local if not already present
		if grep -q "OPENAI_API_KEY=" "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null; then
			warn "OPENAI_API_KEY already set in $BASH_PROFILE_LOCAL_FILE"
		else
			echo "export OPENAI_API_KEY=\"$OPENAI_API_KEY\"" >>"$BASH_PROFILE_LOCAL_FILE"
			success "Added OPENAI_API_KEY to $BASH_PROFILE_LOCAL_FILE"
		fi
	else
		warn "No API key entered; skipping environment variable setup"
	fi

	# Confirm install
	if command -v genmoji >/dev/null 2>&1; then
		success "Genmoji is now available as: $(command -v genmoji)"
	else
		warn "Genmoji script installed, but not found in \$PATH"
		info "You may need to add '$install_dir' to your PATH manually."
	fi

	return 0
}

# Install Gitmoji Fuzzy Git commit hook
install_gitmoji_fuzzy_hook() {
	log "🔎 Checking if gitmoji-fuzzy-hook is installed..."

	local filepath hooks_dir hook_path install_repo install_dir repo_url target templates_dir
	install_repo="gitmoji-fuzzy-hook"
	install_dir="$HOME/.local/lib/$install_repo"
	repo_url="https://gitlab.com/raabf/$install_repo.git"

	# Clone or update the repo
	log "📥 Downloading $install_repo"
	if [[ ! -d "$install_dir/.git" ]]; then
		mkdir -p "$install_dir" || {
			error "Failed to create directory: $install_dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}

		run_quietly git clone "$repo_url" "$install_dir" || {
			error "Failed to clone $repo_url"
			return 74 # I/O error from curl or tar (EX_IOERR)
		}
		success "Downloaded $install_repo into $install_dir"
	else
		info "Updating existing $install_repo repo"
		git -C "$install_dir" pull --quiet || warn "Could not update $install_repo"
	fi

	log "🎉 Installing gitmoji-fuzzy-hook"
	target="$HOME/.local/bin/$install_repo-init"
	mkdir -p "$(dirname "$target")" || {
		error "Failed to create directory: $(dirname "$target")"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "🔗 Symlinking $install_dir/bin/${install_repo-init}.sh → $target"
	if ln -sfn "$install_dir/bin/${install_repo}-init.sh" "$target"; then
		success "Symlinked $install_dir/bin/${install_repo}-init.sh → $target"
	else
		error "Failed to symlink from $install_dir/bin/${install_repo}-init.sh to $target"
		return 70 # Software error: symlink failed (EX_SOFTWARE)
	fi

	# Install hook to both locations
	hooks_dir="$HOME/.config/git/hooks"
	templates_dir="$HOME/.config/git/templates/hooks"
	for dir in "$templates_dir" "$hooks_dir"; do
		mkdir -p "$dir" || {
			error "Failed to create hook directory: $dir"
			return 73 # Can't create directory (EX_CANTCREAT)
		}
		hook_path="$dir/prepare-commit-msg"
		log "🔗 Installing $install_repo to $hook_path"
		if run_quietly $target >"$hook_path"; then
			chmod +x "$hook_path"
			success "Installed $install_repo to $hook_path"
		else
			error "Failed to generate prepare-commit-msg in $dir"
			return 70 # Software error: symlink failed (EX_SOFTWARE)
		fi
	done

	success "$install_repo installed and configured for Git hooks and templates"
	return 0
}

# Install FZF keybindings and shell completion
setup_fzf_keybindings() {
	log "🔎 Checking for FZF keybindings and fuzzy completion..."

	# Ensure fzf is available
	if ! command -v fzf >/dev/null 2>&1; then
		warn "fzf not found. Attempting to install via Homebrew"

		if ! install_homebrew || ! run_quietly brew install fzf; then
			error "Failed to install fzf"
			return 74 # EX_UNAVAILABLE
		fi

		success "Installed fzf"
	fi

	log "🛠 Setting up FZF keybindings and fuzzy completion"
	local install_script
	install_script="$(brew --prefix)/opt/fzf/install"

	if [[ ! -x "$install_script" ]]; then
		error "FZF install script not found at $install_script"
		return 66 # EX_NOINPUT
	fi

	log "🔧 Running fzf install script (no rc updates)"
	if run_quietly "$install_script" --key-bindings --completion --no-update-rc; then
		success "FZF keybindings and completion installed"
	else
		error "FZF install script failed to run successfully"
		return 70
	fi

	return 0
}

# Prompt user for GitHub token and write to .netrc and local bash profile
setup_github_token() {
	log "🔎 Checking for GitHub token..."

	local token_input=""
	if [[ -n "${GITHUB_TOKEN:-}" ]]; then
		token_input="$GITHUB_TOKEN"
		info "GITHUB_TOKEN is already set in environment"
	else
		log "🔐 Configuring GitHub token"
		prompt_for token_input "🔑 Enter your GitHub personal access token"
	fi

	if [[ -z "$token_input" ]]; then
		warn "No token entered, skipping GitHub token setup"
		return 0
	fi

	export GITHUB_TOKEN="$token_input"
	local netrc_path
	netrc_path="$HOME/.netrc"

	# Update .netrc
	if ! grep -q "machine github.com" "$netrc_path" 2>/dev/null; then
		log "📝 Writing GitHub credentials to $netrc_path"
		cat <<EOF >>"$netrc_path"
machine github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine api.github.com
  login $GITHUB_TOKEN
  password x-oauth-basic

machine raw.githubusercontent.com
  login $GITHUB_TOKEN
  password x-oauth-basic
EOF
		chmod 600 "$netrc_path"
		success "Added GITHUB TOKEN to $netrc_path"
	else
		warn "$netrc_path already contains GitHub credentials"
	fi

	# Add export to .bash_profile.local
	log "📝 Writing GITHUB_TOKEN to $BASH_PROFILE_LOCAL_FILE"
	if grep -q "GITHUB_TOKEN=" "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null; then
		warn "GITHUB_TOKEN already set in $BASH_PROFILE_LOCAL_FILE"
	else
		echo "export GITHUB_TOKEN=\"$GITHUB_TOKEN\"" >>"$BASH_PROFILE_LOCAL_FILE"
		success "Added GITHUB_TOKEN to $BASH_PROFILE_LOCAL_FILE"
	fi

	return 0
}

# Set up Git user.name and user.email from prompt if unset
setup_git_author() {
	log "🔎 Checking if Git author name and email are setup..."

	if ! command -v git >/dev/null 2>&1; then
		error "Git is not installed. Skipping Git author setup"
		return 69 # git unavailable (EX_UNAVAILABLE)
	fi

	log "🪪 Setting up Git author name and email"
	local current_name current_email input_name input_email
	current_name=$(git config --file "$GIT_CONFIG_FILE" user.name 2>/dev/null || echo "")
	current_email=$(git config --file "$GIT_CONFIG_FILE" user.email 2>/dev/null || echo "")

	if [[ -z "$current_name" ]]; then
		prompt_for input_name "👤 Enter Git name [default: $GIT_AUTHOR_NAME]"
		input_name="${input_name:-$GIT_AUTHOR_NAME}"
		git config --file "$GIT_CONFIG_FILE" user.name "$input_name"
		success "Git name set to: $input_name"
	else
		info "Git name already set to: $current_name"
	fi

	if [[ -z "$current_email" ]]; then
		prompt_for input_email "✉️ Enter Git email [default: $GIT_AUTHOR_EMAIL]"
		input_email="${input_email:-$GIT_AUTHOR_EMAIL}"
		git config --file "$GIT_CONFIG_FILE" user.email "$input_email"
		success "Git email set to: $input_email"
	else
		info "Git email already set to: $current_email"
	fi

	log "📝 Writing Git author variables to $BASH_PROFILE_LOCAL_FILE"
	{
		grep -q '^export GIT_AUTHOR_NAME=' "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null || echo "export GIT_AUTHOR_NAME=\"$input_name\"" >>"$BASH_PROFILE_LOCAL_FILE"
		grep -q '^export GIT_AUTHOR_EMAIL=' "$BASH_PROFILE_LOCAL_FILE" 2>/dev/null || echo "export GIT_AUTHOR_EMAIL=\"$input_email\"" >>"$BASH_PROFILE_LOCAL_FILE"
	} && success "Git author variables exported to $BASH_PROFILE_LOCAL_FILE"

	return 0
}

# Generate and configure a GPG key for Git commit signing
setup_gpg_key() {
	log "🔎 Checking for GPG installation..."

	if ! command -v gpg &>/dev/null; then
		warn "GPG not found. Attempting to install via Homebrew..."

		if ! install_homebrew || ! run_quietly brew install gnupg; then
			error "Homebrew installation failed during GPG setup"
			return 69 # homebrew unavailable (EX_UNAVAILABLE)
		fi

		success "Installed GPG"
	fi

	export GNUPGHOME="${GNUPGHOME:-$HOME/.config/gnupg}"
	mkdir -p "$GNUPGHOME" || {
		error "Failed to create directory: $GNUPGHOME"
		return 73 # Can't create directory (EX_CANTCREAT)
	}

	log "🔒 Securing GPG directory permissions..."
	chmod 700 "$GNUPGHOME"
	find "$GNUPGHOME" -type f -exec chmod 600 {} \;

	log "🔑 Generating and configuring GPG key..."
	local gpg_key
	gpg_key=$(run_quietly gpg --list-secret-keys --keyid-format LONG 2>/dev/null | awk '/sec/{print $2}' | awk -F'/' '{print $2}' | head -n1)

	if [[ -z "$gpg_key" ]]; then
		log "🔧 No GPG key found — generating one now (interactive)..."
		gpg --gen-key || {
			error "GPG key generation failed"
			return 70
		}
		gpg_key=$(run_quietly gpg --list-secret-keys --keyid-format LONG | awk '/sec/{print $2}' | awk -F'/' '{print $2}' | head -n1)
	fi

	if [[ -z "$gpg_key" ]]; then
		error "Failed to find or generate GPG key"
		return 67 # Missing user input (EX_NOUSER)
	fi

	log "🔗 Setting Git signing key to: $gpg_key"
	git config --file "$GIT_CONFIG_FILE" user.signingkey "$gpg_key"

	local tmp_export_file
	tmp_export_file="$(mktemp "/tmp/gpg-key-${gpg_key}.XXXXXX.asc")"
	if gpg --armor --export "$gpg_key" >"$tmp_export_file"; then
		info "📄 GPG public key exported to: $tmp_export_file"
		log "🔗 Add this GPG key to GitHub: https://github.com/settings/keys"
	else
		error "Failed to export GPG key."
		return 74 # Export failed (EX_IOERR)
	fi

	success "GPG setup and directory permissions secured."

	return 0
}

generate_gpg_key() {
	log "🔑 Generating GPG key (non-interactively)..."

	# Create GPG config directory
	export GNUPGHOME="${GNUPGHOME:-$HOME/.config/gnupg}"
	mkdir -p "$GNUPGHOME"
	chmod 700 "$GNUPGHOME"
	[[ "${DEBUG:-false}" == "true" ]] && find "$GNUPGHOME"

	local gpg_batch
	gpg_batch=$(mktemp)

	# Create batch file for key generation
	cat <<EOF >"$gpg_batch"
%no-protection
Key-Type: RSA
Key-Length: 4096
Name-Real: $GIT_AUTHOR_NAME
Name-Email: $GIT_AUTHOR_EMAIL
Expire-Date: 0
%commit
EOF

	# Generate key
	if run_quietly gpg --batch --generate-key "$gpg_batch"; then
		chmod 700 "$GNUPGHOME"
		success "GPG key generated for $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>"
	else
		error "Failed to generate GPG key"
		rm -f "$gpg_batch"
		return 70
	fi

	rm -f "$gpg_batch"

	# Display generated key info
	local key_output key_id
	key_output=$(gpg --list-secret-keys --with-colons "$GIT_AUTHOR_EMAIL" 2>/dev/null)
	key_id=$(echo "$key_output" | awk -F: '/^sec/ { print $5 }' | head -n1)

	if [[ -n "$key_id" ]]; then
		info "🔑 GPG Key ID: $key_id"
		git config --file "$GIT_CONFIG_FILE" user.signingkey "$key_id"
		success "GPG signing key configured for Git"
	else
		warn "GPG key generated but could not extract key ID"
		[[ "${DEBUG:-false}" == "true" ]] && echo "$key_output"
	fi

	return 0
}

# Change the login shell to Homebrew Bash if needed
change_login_shell() {
	log "🔎 Checking login shell..."

	local new_shell
	new_shell="$(brew --prefix)/bin/bash"
	if [[ "$SHELL" == "$new_shell" ]]; then
		info "Login shell already set to: $new_shell"
		return 0
	fi

	if [[ ! -x "$new_shell" ]]; then
		error "Target shell does not exist: $new_shell"
		return 66 # EX_NOINPUT
	fi

	if ! grep -Fxq "$new_shell" /etc/shells; then
		log "📝 Writing $new_shell to /etc/shells"

		if [[ "$OS" == "darwin" && -x "$(command -v sudo)" ]]; then
			if ! echo "$new_shell" | sudo tee -a /etc/shells >/dev/null; then
				error "Failed to add $new_shell to /etc/shells"
				return 71 # EX_OSERR
			fi
		elif [[ "$OS" == "linux" && -x "$(command -v sudo)" ]]; then
			if ! echo "$new_shell" | sudo tee -a /etc/shells >/dev/null; then
				error "Failed to add $new_shell to /etc/shells"
				return 71 # EX_OSERR
			fi
		else
			error "Cannot modify /etc/shells without sudo privileges"
			return 69 # EX_UNAVAILABLE
		fi
		success "Added $new_shell to /etc/shells"
	fi

	log "🐚 Changing login shell to: $new_shell"
	if run_quietly sudo chsh -s "$new_shell" "${USER:-$(id -un)}"; then
		success "Login shell changed to: $new_shell"
	else
		error "Failed to change login shell"
		return 71 # EX_OSERR
	fi

	return 0
}

# These need to be global so cleanup can read them
start_time=""
end_time=""
failed_optional=()

# Cleanup function to trap EXIT and summarize results
cleanup() {
	section "🚀 dotfiles installation stats:"

	if [[ -n "$start_time" ]]; then
		end_time=$(date +%s)
		log "⏱️ Completed in $((end_time - start_time)) seconds"
	else
		log "⏱️ Exited before timing could begin"
	fi

	if [[ "${#failed_optional[@]}" -gt 0 ]]; then
		warn "Some optional steps failed and may need to be run manually:"
		for fn in "${failed_optional[@]}"; do
			log "\t - $fn"
		done
	fi
}

trap cleanup EXIT

main() {
	start_time=$(date +%s)

	# print out the banner, no matter what happens on setup
	print_banner
	# print out computer stats that are useful
	print_stats

	# Set up logging first — before any log messages
	init_log_file || echo "⚠️ Log file could not be initialized"

	# Helper to run optional steps
	optional_step() {
		local label="$1"
		shift
		if ! "$@"; then
			failed_optional+=("$label")
		fi
	}

	header "🚀 Starting dotfiles installation..."

	section "🧱 Setting up dependencies, cloning library and installing binary"
	install_homebrew || return $?
	extract_repo || return $?
	clone_repo || return $?
	symlink_binary || return $?
	success "${REPO} cloned, setup, and binary installed" "true"

	section "⚙️ Setting up configurations"
	symlink_dotconfigs || return $?
	symlink_os_files || return $?
	symlink_configs || return $?
	create_bash_profile_local || return $?
	success "Configurations are setup" "true"

	section "📦 Installing and setting up tools"
	install_homebrew_packages || return $?
	install_npm_packages || return $?
	optional_step "install_whalebrew_packages" install_whalebrew_packages
	optional_step "install_macos_apps" install_macos_apps
	optional_step "install_fonts" install_fonts
	optional_step "install_ls_colors" install_ls_colors
	optional_step "install_genmoji" install_genmoji
	optional_step "install_gitmoji_fuzzy_hook" install_gitmoji_fuzzy_hook
	optional_step "setup_fzf_keybindings" setup_fzf_keybindings
	success "Tools are installed and setup" "true"

	#  Tool setup
	section "🔧 Configure authorship"
	setup_github_token || log "🔐 GitHub token setup skipped"
	setup_git_author || return $?
	generate_gpg_key || return $?
	change_login_shell || return $?
	success "Authorship is configured" "true"

	echo -e "${LOG_PREFIX}:"
	success "${REPO} installed. Open a new terminal session" "true"
}

main
